/**
  ******************************************************************************
  * @file    ble_events.h
  * @author  GPM WBL Application team
  * @brief   Header file for Bluetooth Low Energy stack event structures
  *          Autogenerated files, do not edit!!
  ******************************************************************************
  * @attention
  *
  * Copyright (c) 2024 STMicroelectronics.
  * All rights reserved.
  *
  * This software is licensed under terms that can be found in the LICENSE file
  * in the root directory of this software component.
  * If no LICENSE file comes with this software, it is provided AS-IS.
  *
  ******************************************************************************
  */

#ifndef _BLE_EVENTS_H_
#define _BLE_EVENTS_H_

#include "compiler.h"
#include "ble_types.h"

/**
  * @brief   Format of packets coming from BLE Stack.
  */
typedef PACKED(struct) _hci_pckt{
  uint8_t       type;       /*!< Type of packet. For possible values see @ref HCI_pckt_type */
  uint8_t       data[0];    /*!< HCI data packets. Format depends on type field.
                                 It can be casted to one of @ref HCI_data_pckt_structs */
} hci_pckt;

/** @defgroup HCI_pckt_type HCI packet type
  * @{
  */
#define HCI_COMMAND_PKT_TYPE                0x01U  /*!< Not used. */
#define HCI_ACLDATA_PKT_TYPE                0x02U
#define HCI_EVENT_PKT_TYPE                  0x04U
#define HCI_ISODATA_PKT_TYPE                0x05U
#define HCI_COMMAND_EXT_PKT_TYPE            0x81U  /*!< Not used. */
#define HCI_EVENT_EXT_PKT_TYPE	            0x82U
#define HCI_VENDOR_PKT_TYPE                 0xFFU  /*!< Not used. */
/**
  * @}
  */

/** @defgroup HCI_data_pckt_structs Structures for HCI data packets
  * @{
  */

/**
  * @brief   Packet format of events.
  *
  * This is data field of hci_pckt if type field is equal to HCI_EVENT_PKT_TYPE.
  */
typedef PACKED(struct) _hci_event_pckt{
  uint8_t       evt;        /*!< One of @ref HCI_evt_code */
  uint8_t       plen;       /*!< Parameter Total Length, i.e. length of data field. */
  uint8_t       data[0];    /*!< Event payload. To be casted to one of event struct types of @ref HCI_evt_structs. */
} hci_event_pckt;

/**
  * @brief   Packet format of extended proprietary events.
  *
  * This is data field of hci_pckt if type field is equal to HCI_EVENT_EXT_PKT_TYPE.
  */
typedef PACKED(struct) _hci_event_ext_pckt{
  uint8_t       evt;        /*!< HCI_VENDOR_EVT_CODE is the only allowed value. */
  uint16_t      plen;       /*!< Parameter Total Length, i.e. length of data field. */
  uint8_t       data[0];    /*!< Event payload. Currently it can be only an aci_blecore_event.  */
} hci_event_ext_pckt;

/**
  * @brief   Packet format of ACL data packets.
  *
  * This is data field of hci_pckt if type field is equal to HCI_ACLDATA_PKT_TYPE.
  */
typedef PACKED(struct) _hci_acl_data_pckt{
  uint16_t      handle_flags;   /*!< This field includes Handle (12 bits), PB Flag (2 bits) and BC Flag (2 bits). */
  uint16_t      dlen;           /*!< Data Total Length. */
  uint8_t       data[0];        /*!< Data. */
} hci_acl_data_pckt;

/**
  * @brief   Packet format of ISO data packets.
  *
  * This is data field of hci_pckt if type field is equal to HCI_ISODATA_PKT_TYPE.
  */
typedef PACKED(struct) _hci_iso_data_pckt{
  uint16_t      handle_flags; /*!< This field includes Handle (12 bits), PB Flag (2 bits) and TS Flag (1 bit). */
  uint16_t      dlen;         /*!< Data Total Length (14 bits used, 2 msb are reserved). */
  uint8_t       data[0];      /*!< Data. Format is described in Core v5.4 Vol. 4, part E, section 5.4.5. */
} hci_iso_data_pckt;

/**
  * @}
  */

/**
 *@addtogroup HCI HCI
 *@brief Standard Host Controller Interface.
 *@{
 */

/** @defgroup HCI_evt HCI events
  * @{
  */

/** @defgroup HCI_evt_code HCI event codes
  * @{
  */

#define HCI_DISCONNECTION_COMPLETE_EVT_CODE                                    0x05
#define HCI_ENCRYPTION_CHANGE_EVT_CODE                                         0x08
#define HCI_READ_REMOTE_VERSION_INFORMATION_COMPLETE_EVT_CODE                  0x0C
#define HCI_HARDWARE_ERROR_EVT_CODE                                            0x10
#define HCI_NUMBER_OF_COMPLETED_PACKETS_EVT_CODE                               0x13
#define HCI_DATA_BUFFER_OVERFLOW_EVT_CODE                                      0x1A
#define HCI_ENCRYPTION_KEY_REFRESH_COMPLETE_EVT_CODE                           0x30
#define HCI_AUTHENTICATED_PAYLOAD_TIMEOUT_EXPIRED_EVT_CODE                     0x57
#define HCI_LE_META_EVT_CODE                                                   0x3E
#define HCI_VENDOR_EVT_CODE                                                    0xFF

/**
  * @}
  */

/* Structs for events are never allocated. They are only used to cast a specific
 event type. For this reason, this macro has no much importance for events.  */
#define HCI_MAX_PAYLOAD_SIZE 532

/** @defgroup HCI_evt_structs HCI event structures
  * Types to be used to cast data field of @ref hci_event_pckt type
  * @{
  */

/**
 * The Disconnection Complete event occurs when a connection is terminated. The
 * status parameter indicates if the disconnection was successful or not. The
 * reason parameter indicates the reason for the disconnection if the
 * disconnection was successful. If the disconnection was not successful, the
 * value of the reason parameter can be ignored by the Host. For example, this
 * can be the case if the Host has issued the Disconnect command and there was a
 * parameter error, or the command was not presently allowed, or a
 * Connection_Handle that didn't correspond to a connection was given.
 */
typedef PACKED(struct) hci_disconnection_complete_event_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
/**
 * Connection_Handle which was disconnected.
 * Values:
 * - 0x0000 ... 0x0EFF
 */
  uint16_t Connection_Handle;
/**
 * Reason for disconnection. See Error Codes.
 */
  uint8_t Reason;
} hci_disconnection_complete_event_rp0;

/**
 * The Encryption Change event is used to indicate that the change of the
 * encryption mode has been completed. The Connection_Handle will be a
 * Connection_Handle for an ACL connection. The Encryption_Enabled event
 * parameter specifies the new Encryption_Enabled parameter for the
 * Connection_Handle specified by the Connection_Handle event parameter. This
 * event will occur on both devices to notify the Hosts when Encryption has
 * changed for the specified Connection_Handle between two devices. Note: This
 * event shall not be generated if encryption is paused or resumed; during a
 * role switch, for example. The meaning of the Encryption_Enabled parameter
 * depends on whether the Host has indicated support for Secure Connections in
 * the Secure_Connections_Host_Support parameter. When
 * Secure_Connections_Host_Support is 'disabled' or the Connection_Handle refers
 * to an LE link, the Controller shall only use Encryption_Enabled values 0x00
 * (OFF) and 0x01 (ON). (See Bluetooth Specification v.4.1, Vol. 2, Part E,
 * 7.7.8)
 */
typedef PACKED(struct) hci_encryption_change_event_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
/**
 * Connection handle that identifies the connection.
 * Values:
 * - 0x0000 ... 0x0EFF
 */
  uint16_t Connection_Handle;
/**
 * Link Level Encryption.
 * Values:
 * - 0x00: Link Level Encryption OFF
 * - 0x01: Link Level Encryption is ON with AES-CCM
 */
  uint8_t Encryption_Enabled;
} hci_encryption_change_event_rp0;

/**
 * The Read Remote Version Information Complete event is used to indicate the
 * completion of the process obtaining the version information of the remote
 * Controller specified by the Connection_Handle event parameter. The
 * Connection_Handle shall be for an ACL connection. The Version event parameter
 * defines the specification version of the LE Controller. The Manufacturer_Name
 * event parameter indicates the manufacturer of the remote Controller. The
 * Subversion event parameter is controlled by the manufacturer and is
 * implementation dependent. The Subversion event parameter defines the various
 * revisions that each version of the Bluetooth hardware will go through as
 * design processes change and errors are fixed. This allows the software to
 * determine what Bluetooth hardware is being used and, if necessary, to work
 * around various bugs in the hardware. When the Connection_Handle is associated
 * with an LE-U logical link, the Version event parameter shall be Link Layer
 * VersNr parameter, the Manufacturer_Name event parameter shall be the CompId
 * parameter, and the Subversion event parameter shall be the SubVersNr
 * parameter. (See Bluetooth Specification v.4.1, Vol. 2, Part E, 7.7.12)
 */
typedef PACKED(struct) hci_read_remote_version_information_complete_event_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
/**
 * Connection handle that identifies the connection.
 * Values:
 * - 0x0000 ... 0x0EFF
 */
  uint16_t Connection_Handle;
/**
 * Version of the Current LMP in the remote Controller
 */
  uint8_t Version;
/**
 * Manufacturer Name of the remote Controller
 */
  uint16_t Manufacturer_Name;
/**
 * Subversion of the LMP in the remote Controller
 */
  uint16_t Subversion;
} hci_read_remote_version_information_complete_event_rp0;

/**
 * The Hardware Error event is used to indicate some implementation specific
 * type of hardware failure for the controller. This event is used to notify the
 * Host that a hardware failure has occurred in the Controller.
 */
typedef PACKED(struct) hci_hardware_error_event_rp0_s {
/**
 * Error code 0x01 and 0x02 are errors generally caused by hardware issue on the
 * PCB; another possible cause is a slow crystal startup. In the latter case,
 * the HS_STARTUP_TIME in the device configuration needs to be tuned. Error code
 * 0x03 indicates an internal error of the protocol stack. This event with error
 * code 0x04 is raised when a radio interrupt is served late. This usually
 * happens when interrupts are disabled for too long time or when a Flash
 * operation is performed (which can be also triggered by the Stack to store
 * bonding information). Stack will try to recover the situation, so there is
 * normally no need to reset the device. However this condition should be
 * avoided as much as possible. Error code 0x05 is raised when an error happens
 * during a TX transaction. After this event is received with error code 0x00,
 * 0x01, 0x02 or 0x03, it is recommended to force a device reset.
 * Values:
 * - 0x00: Generic HW error
 * - 0x01: Radio state error
 * - 0x02: Timer overrun error
 * - 0x03: Internal queue overflow error
 * - 0x04: Late Radio ISR
 * - 0x05: TX Error
 */
  uint8_t Hardware_Code;
} hci_hardware_error_event_rp0;

/**
 * The Number Of Completed Packets event is used by the Controller to indicate
 * to the Host how many HCI Data Packets have been completed (transmitted or
 * flushed) for each Connection_Handle since the previous Number Of Completed
 * Packets event was sent to the Host. This means that the corresponding buffer
 * space has been freed in the Controller. Based on this information, and the
 * HC_Total_Num_ACL_Data_Packets and HC_Total_Num_Synchronous_- Data_Packets
 * return parameter of the Read_Buffer_Size command, the Host can determine for
 * which Connection_Handles the following HCI Data Packets should be sent to the
 * Controller. The Number Of Completed Packets event must not be sent before the
 * corresponding Connection Complete event. While the Controller has HCI data
 * packets in its buffer, it must keep sending the Number Of Completed Packets
 * event to the Host at least periodically, until it finally reports that all
 * the pending ACL Data Packets have been transmitted or flushed.
 */
typedef PACKED(struct) hci_number_of_completed_packets_event_rp0_s {
/**
 * The number of Connection_Handles and Num_HCI_Data_Packets parameters pairs
 * contained in this event
 */
  uint8_t Number_of_Handles;
/**
 * See @ref packed_Handle_Packets_Pair_Entry_t
 */
  packed_Handle_Packets_Pair_Entry_t Handle_Packets_Pair_Entry[(HCI_MAX_PAYLOAD_SIZE - 1)/sizeof(packed_Handle_Packets_Pair_Entry_t)];
} hci_number_of_completed_packets_event_rp0;

/**
 * This event is used to indicate that the Controller's data buffers have been
 * overflowed. This can occur if the Host has sent more packets than allowed.
 * The Link_Type parameter is used to indicate that the overflow was caused by
 * ACL data.
 */
typedef PACKED(struct) hci_data_buffer_overflow_event_rp0_s {
/**
 * On which type of channel overflow has occurred.
 * Values:
 * - 0x01: ACL Buffer Overflow
 */
  uint8_t Link_Type;
} hci_data_buffer_overflow_event_rp0;

/**
 * The Encryption Key Refresh Complete event is used to indicate to the Host
 * that the encryption key was refreshed on the given Connection_Handle any time
 * encryption is paused and then resumed. If the Encryption Key Refresh Complete
 * event was generated due to an encryption pause and resume operation embedded
 * within a change connection link key procedure, the Encryption Key Refresh
 * Complete event shall be sent prior to the Change Connection Link Key Complete
 * event. If the Encryption Key Refresh Complete event was generated due to an
 * encryption pause and resume operation embedded within a role switch
 * procedure, the Encryption Key Refresh Complete event shall be sent prior to
 * the Role Change event.
 */
typedef PACKED(struct) hci_encryption_key_refresh_complete_event_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
/**
 * Connection handle that identifies the connection.
 * Values:
 * - 0x0000 ... 0x0EFF
 */
  uint16_t Connection_Handle;
} hci_encryption_key_refresh_complete_event_rp0;

/**
 * The HCI_Authenticated_Payload_Timeout_Expired event is used to indicate that
 * a packet containing a valid MIC on the Connection_Handle was not received
 * within the authenticatedPayloadTO. Note: A Host may choose to disconnect the
 * link when this occurs.
 */
typedef PACKED(struct) hci_authenticated_payload_timeout_expired_event_rp0_s {
/**
 * Connection handle that identifies the connection.
 * Values:
 * - 0x0000 ... 0x0EFF
 */
  uint16_t Connection_Handle;
} hci_authenticated_payload_timeout_expired_event_rp0;

/**
  * @brief   Format of Standard LE Meta Events
  *
  * This is data field of @ref hci_event_pckt if evt field is equal to HCI_LE_META_EVT_CODE.
  */
typedef PACKED(struct) hci_le_meta_event_s {
  uint8_t       subevent;   /*!< A value of @ref HCI_le_meta_evt_code. */
  uint8_t       data[0];    /*!< LE Meta event. To be casted to a struct of @ref HCI_le_meta_evt_structs. */
} hci_le_meta_event;

/**
  * @brief   Format of proprietary events.
  *
  * This is data field of @ref hci_event_pckt or @ref hci_event_ext_pckt if evt field is equal to HCI_VENDOR_EVT_CODE.
  */
typedef PACKED(struct) aci_blecore_event_s {
  uint16_t      ecode;      /*!< A proprietary ACI event code. See @ref ACI_HAL_evt_code (HAL/LL), @ref ACI_GAP_evt_code (GAP),
                                 @ref ACI_GATT_evt_code (GATT), @ref ACI_L2CAP_evt_code (L2CAP). */
  uint8_t       data[0];    /*!< Proprietary event parameters. To be casted to a struct of @ref ACI_hal_evt_structs, @ref ACI_gap_evt_structs,
                                 @ref ACI_gatt_evt_structs, @ref ACI_l2cap_evt_structs.  */
} aci_blecore_event;

/**
  * @}
  */


/** @defgroup HCI_le_meta_evt_code HCI LE Meta subevent codes
  * Codes found in subevent field of hci_le_meta_event struct.
  * @{
  */
#define HCI_LE_CONNECTION_COMPLETE_SUBEVT_CODE                                 0x01
#define HCI_LE_ADVERTISING_REPORT_SUBEVT_CODE                                  0x02
#define HCI_LE_CONNECTION_UPDATE_COMPLETE_SUBEVT_CODE                          0x03
#define HCI_LE_READ_REMOTE_FEATURES_COMPLETE_SUBEVT_CODE                       0x04
#define HCI_LE_LONG_TERM_KEY_REQUEST_SUBEVT_CODE                               0x05
#define HCI_LE_DATA_LENGTH_CHANGE_SUBEVT_CODE                                  0x07
#define HCI_LE_READ_LOCAL_P256_PUBLIC_KEY_COMPLETE_SUBEVT_CODE                 0x08
#define HCI_LE_GENERATE_DHKEY_COMPLETE_SUBEVT_CODE                             0x09
#define HCI_LE_ENHANCED_CONNECTION_COMPLETE_SUBEVT_CODE                        0x0A
#define HCI_LE_DIRECTED_ADVERTISING_REPORT_SUBEVT_CODE                         0x0B
#define HCI_LE_PHY_UPDATE_COMPLETE_SUBEVT_CODE                                 0x0C
#define HCI_LE_EXTENDED_ADVERTISING_REPORT_SUBEVT_CODE                         0x0D
#define HCI_LE_PERIODIC_ADVERTISING_SYNC_ESTABLISHED_SUBEVT_CODE               0x0E
#define HCI_LE_PERIODIC_ADVERTISING_REPORT_SUBEVT_CODE                         0x0F
#define HCI_LE_PERIODIC_ADVERTISING_SYNC_LOST_SUBEVT_CODE                      0x10
#define HCI_LE_SCAN_TIMEOUT_SUBEVT_CODE                                        0x11
#define HCI_LE_ADVERTISING_SET_TERMINATED_SUBEVT_CODE                          0x12
#define HCI_LE_SCAN_REQUEST_RECEIVED_SUBEVT_CODE                               0x13
#define HCI_LE_CHANNEL_SELECTION_ALGORITHM_SUBEVT_CODE                         0x14
#define HCI_LE_CONNECTIONLESS_IQ_REPORT_SUBEVT_CODE                            0x15
#define HCI_LE_CONNECTION_IQ_REPORT_SUBEVT_CODE                                0x16
#define HCI_LE_CTE_REQUEST_FAILED_SUBEVT_CODE                                  0x17
#define HCI_LE_PERIODIC_ADVERTISING_SYNC_TRANSFER_RECEIVED_SUBEVT_CODE         0x18
#define HCI_LE_CIS_ESTABLISHED_SUBEVT_CODE                                     0x19
#define HCI_LE_CIS_REQUEST_SUBEVT_CODE                                         0x1A
#define HCI_LE_CREATE_BIG_COMPLETE_SUBEVT_CODE                                 0x1B
#define HCI_LE_TERMINATE_BIG_COMPLETE_SUBEVT_CODE                              0x1C
#define HCI_LE_BIG_SYNC_ESTABLISHED_SUBEVT_CODE                                0x1D
#define HCI_LE_BIG_SYNC_LOST_SUBEVT_CODE                                       0x1E
#define HCI_LE_REQUEST_PEER_SCA_COMPLETE_SUBEVT_CODE                           0x1F
#define HCI_LE_PATH_LOSS_THRESHOLD_SUBEVT_CODE                                 0x20
#define HCI_LE_TRANSMIT_POWER_REPORTING_SUBEVT_CODE                            0x21
#define HCI_LE_BIGINFO_ADVERTISING_REPORT_SUBEVT_CODE                          0x22
#define HCI_LE_SUBRATE_CHANGE_SUBEVT_CODE                                      0x23
#define HCI_LE_PERIODIC_ADVERTISING_SYNC_ESTABLISHED_V2_SUBEVT_CODE            0x24
#define HCI_LE_PERIODIC_ADVERTISING_REPORT_V2_SUBEVT_CODE                      0x25
#define HCI_LE_PERIODIC_ADVERTISING_SYNC_TRANSFER_RECEIVED_V2_SUBEVT_CODE      0x26
#define HCI_LE_PERIODIC_ADVERTISING_SUBEVENT_DATA_REQUEST_SUBEVT_CODE          0x27
#define HCI_LE_PERIODIC_ADVERTISING_RESPONSE_REPORT_SUBEVT_CODE                0x28
#define HCI_LE_ENHANCED_CONNECTION_COMPLETE_V2_SUBEVT_CODE                     0x29
/**
  * @}
  */

/** @defgroup HCI_le_meta_evt_structs HCI LE Meta event structures
  * Types to be used to cast data field of hci_le_meta_event type
  * @{
  */

/**
 * The LE Connection Complete event indicates to both of the Hosts forming the
 * connection that a new connection has been created. Upon the creation of the
 * connection a Connection_Handle shall be assigned by the Controller, and
 * passed to the Host in this event. If the connection establishment fails this
 * event shall be provided to the Host that had issued the LE_Create_Connection
 * command. This event indicates to the Host which issued a LE_Create_Connection
 * command and received a Command Status event if the connection establishment
 * failed or was successful. The Central_Clock_Accuracy parameter is only valid
 * for a peripheral. On a central, this parameter shall be set to 0x00.
 */
typedef PACKED(struct) hci_le_connection_complete_event_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
/**
 * Connection handle to be used to identify the connection with the peer device.
 * Values:
 * - 0x0000 ... 0x0EFF
 */
  uint16_t Connection_Handle;
/**
 * Role of the local device in the connection.
 * Values:
 * - 0x00: Central
 * - 0x01: Peripheral
 */
  uint8_t Role;
/**
 * The address type of the peer device.
 * Values:
 * - 0x00: Public Device Address
 * - 0x01: Random Device Address
 */
  uint8_t Peer_Address_Type;
/**
 * Public Device Address or Random Device Address of the peer device
 */
  uint8_t Peer_Address[6];
/**
 * Connection interval used on this connection. Time = N * 1.25 msec
 * Values:
 * - 0x0006 (7.50 ms)  ... 0x0C80 (4000.00 ms)
 */
  uint16_t Connection_Interval;
/**
 * Maximum Peripheral latency for the connection in number of connection events.
 * Values:
 * - 0x0000 ... 0x01F3
 */
  uint16_t Peripheral_Latency;
/**
 * Supervision timeout for the LE Link. It shall be a multiple of 10 ms and
 * larger than (1 + connPeripheralLatency) * connInterval * 2. Time = N * 10
 * msec.
 * Values:
 * - 0x000A (100 ms)  ... 0x0C80 (32000 ms)
 */
  uint16_t Supervision_Timeout;
/**
 * Central clock accuracy. Only valid for a Peripheral.
 * Values:
 * - 0x00: 500 ppm
 * - 0x01: 250 ppm
 * - 0x02: 150 ppm
 * - 0x03: 100 ppm
 * - 0x04: 75 ppm
 * - 0x05: 50 ppm
 * - 0x06: 30 ppm
 * - 0x07: 20 ppm
 */
  uint8_t Central_Clock_Accuracy;
} hci_le_connection_complete_event_rp0;

/**
 * The LE Advertising Report event indicates that a Bluetooth device or multiple
 * Bluetooth devices have responded to an active scan or received some
 * information during a passive scan. The Controller may queue these advertising
 * reports and send information from multiple devices in one LE Advertising
 * Report event.
 */
typedef PACKED(struct) hci_le_advertising_report_event_rp0_s {
/**
 * Number of responses in this event.
 * Values:
 * - 0x01
 */
  uint8_t Num_Reports;
/**
 * See @ref packed_Advertising_Report_t
 */
  packed_Advertising_Report_t Advertising_Report; /* N elements of variable size */
} hci_le_advertising_report_event_rp0;

/**
 * The LE Connection Update Complete event is used to indicate that the
 * Controller process to update the connection has completed. On a peripheral,
 * if no connection parameters are updated, then this event shall not be issued.
 * On a central, this event shall be issued if the Connection_Update command was
 * sent.
 */
typedef PACKED(struct) hci_le_connection_update_complete_event_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
/**
 * Connection handle to be used to identify the connection with the peer device.
 * Values:
 * - 0x0000 ... 0x0EFF
 */
  uint16_t Connection_Handle;
/**
 * Connection interval used on this connection. Time = N * 1.25 msec
 * Values:
 * - 0x0006 (7.50 ms)  ... 0x0C80 (4000.00 ms)
 */
  uint16_t Connection_Interval;
/**
 * Maximum Peripheral latency for the connection in number of connection events.
 * Values:
 * - 0x0000 ... 0x01F3
 */
  uint16_t Peripheral_Latency;
/**
 * Supervision timeout for the LE Link. It shall be a multiple of 10 ms and
 * larger than (1 + connPeripheralLatency) * connInterval * 2. Time = N * 10
 * msec.
 * Values:
 * - 0x000A (100 ms)  ... 0x0C80 (32000 ms)
 */
  uint16_t Supervision_Timeout;
} hci_le_connection_update_complete_event_rp0;

/**
 * The LE Read Remote Features Complete event is used to indicate the completion
 * of the process of the Controller obtaining the used features of the remote
 * Bluetooth device specified by the Connection_Handle event parameter.
 */
typedef PACKED(struct) hci_le_read_remote_features_complete_event_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
/**
 * Connection handle to be used to identify the connection with the peer device.
 * Values:
 * - 0x0000 ... 0x0EFF
 */
  uint16_t Connection_Handle;
/**
 * Bit Mask List of used LE features. For details see LE Link Layer
 * specification.
 */
  uint8_t LE_Features[8];
} hci_le_read_remote_features_complete_event_rp0;

/**
 * The LE Long Term Key Request event indicates that the central device is
 * attempting to encrypt or re-encrypt the link and is requesting the Long Term
 * Key from the Host. (See [Vol 6] Part B, Section 5.1.3).
 */
typedef PACKED(struct) hci_le_long_term_key_request_event_rp0_s {
/**
 * Connection handle to be used to identify the connection with the peer device.
 * Values:
 * - 0x0000 ... 0x0EFF
 */
  uint16_t Connection_Handle;
/**
 * 64-bit random number
 */
  uint8_t Random_Number[8];
/**
 * 16-bit encrypted diversifier
 */
  uint16_t Encrypted_Diversifier;
} hci_le_long_term_key_request_event_rp0;

/**
 * The LE Data Length Change event notifies the Host of a change to either the
 * maximum Payload length or the maximum transmission time of Data Channel PDUs
 * in either direction. The values reported are the maximum that will actually
 * be used on the connection following the change.
 */
typedef PACKED(struct) hci_le_data_length_change_event_rp0_s {
/**
 * Connection_Handle to be used to identify a connection.
 */
  uint16_t Connection_Handle;
/**
 * The maximum number of payload octets in a Link Layer Data Channel PDU that
 * the local Controller will send on this connection (connEffectiveMaxTxOctets
 * defined in [Vol 6] Part B, Section 4.5.10). Range 0x001B-0x00FB (0x0000 -
 * 0x001A and 0x00FC - 0xFFFF Reserved for future use)
 */
  uint16_t MaxTxOctets;
/**
 * The maximum time that the local Controller will take to send a Link Layer
 * Data Channel PDU on this connection (connEffectiveMaxTx-Time defined in [Vol
 * 6] Part B, Section 4.5.10). Range 0x0148-0x0848 (0x0000 - 0x0127 and 0x0849 -
 * 0xFFFF Reserved for future use)
 */
  uint16_t MaxTxTime;
/**
 * The maximum number of payload octets in a Link Layer Data Channel PDU that
 * the local controller expects to receive on this connection
 * (connEfectiveMaxRxOctets defined in [Vol 6] Part B, Section 4.5.10). Range
 * 0x001B-0x00FB (0x0000 - 0x001A and 0x00FC - 0xFFFF Reserved for future use)
 */
  uint16_t MaxRxOctets;
/**
 * The maximum time that the local Controller expects to take to receive a Link
 * Layer Data Channel PDU on this connection (connEffectiveMax-RxTime defined in
 * [Vol 6] Part B, Section 4.5.10). Range 0x0148-0x0848 (0x0000 - 0x0127 and
 * 0x0849 - 0xFFFF Reserved for future use)
 */
  uint16_t MaxRxTime;
} hci_le_data_length_change_event_rp0;

/**
 * This event is generated when local P-256 key generation is complete.
 */
typedef PACKED(struct) hci_le_read_local_p256_public_key_complete_event_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
/**
 * Local P-256 public key.
 */
  uint8_t Local_P256_Public_Key[64];
} hci_le_read_local_p256_public_key_complete_event_rp0;

/**
 * This event indicates that LE Diffie Hellman key generation has been completed
 * by the Controller.
 */
typedef PACKED(struct) hci_le_generate_dhkey_complete_event_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
/**
 * Diffie Hellman Key
 */
  uint8_t DHKey[32];
} hci_le_generate_dhkey_complete_event_rp0;

/**
 * The LE Enhanced Connection Complete event indicates to both of the Hosts
 * forming the connection that a new connection has been created. Upon the
 * creation of the connection a Connection_Handle shall be assigned by the
 * Controller, and passed to the Host in this event. If the connection
 * establishment fails, this event shall be provided to the Host that had issued
 * the LE_Create_Connection command. If this event is unmasked and LE Connection
 * Complete event is unmasked, only the LE Enhanced Connection Complete event is
 * sent when a new connection has been completed. This event indicates to the
 * Host that issued a LE_Create_Connection command and received a Command Status
 * event if the connection establishment failed or was successful. The
 * Central_Clock_Accuracy parameter is only valid for a peripheral. On a
 * central, this parameter shall be set to 0x00.
 */
typedef PACKED(struct) hci_le_enhanced_connection_complete_event_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
/**
 * Connection handle to be used to identify the connection with the peer device.
 * Values:
 * - 0x0000 ... 0x0EFF
 */
  uint16_t Connection_Handle;
/**
 * Role of the local device in the connection.
 * Values:
 * - 0x00: Central
 * - 0x01: Peripheral
 */
  uint8_t Role;
/**
 * 0x00 Public Device Address 0x01 Random Device Address 0x02 Public Identity
 * Address (Corresponds to Resolved Private Address) 0x03 Random (Static)
 * Identity Address (Corresponds to Resolved Private Address)
 * Values:
 * - 0x00: Public Device Address
 * - 0x01: Random Device Address
 * - 0x02: Public Identity Address
 * - 0x03: Random (Static) Identity Address
 */
  uint8_t Peer_Address_Type;
/**
 * Public Device Address, Random Device Address, Public Identity Address or
 * Random (static) Identity Address of the device to be connected.
 */
  uint8_t Peer_Address[6];
/**
 * Resolvable Private Address being used by the local device for this
 * connection. This is only valid when the Own_Address_Type is set to 0x02 or
 * 0x03. For other Own_Address_Type values, the Controller shall return all
 * zeros.
 */
  uint8_t Local_Resolvable_Private_Address[6];
/**
 * Resolvable Private Address being used by the peer device for this connection.
 * This is only valid for Peer_Address_Type 0x02 and 0x03. For other
 * Peer_Address_Type values, the Controller shall return all zeros.
 */
  uint8_t Peer_Resolvable_Private_Address[6];
/**
 * Connection interval used on this connection. Time = N * 1.25 msec
 * Values:
 * - 0x0006 (7.50 ms)  ... 0x0C80 (4000.00 ms)
 */
  uint16_t Connection_Interval;
/**
 * Maximum Peripheral latency for the connection in number of connection events.
 * Values:
 * - 0x0000 ... 0x01F3
 */
  uint16_t Peripheral_Latency;
/**
 * Supervision timeout for the LE Link. It shall be a multiple of 10 ms and
 * larger than (1 + connPeripheralLatency) * connInterval * 2. Time = N * 10
 * msec.
 * Values:
 * - 0x000A (100 ms)  ... 0x0C80 (32000 ms)
 */
  uint16_t Supervision_Timeout;
/**
 * Central clock accuracy. Only valid for a Peripheral.
 * Values:
 * - 0x00: 500 ppm
 * - 0x01: 250 ppm
 * - 0x02: 150 ppm
 * - 0x03: 100 ppm
 * - 0x04: 75 ppm
 * - 0x05: 50 ppm
 * - 0x06: 30 ppm
 * - 0x07: 20 ppm
 */
  uint8_t Central_Clock_Accuracy;
} hci_le_enhanced_connection_complete_event_rp0;

/**
 * The HCI_LE_Directed_Advertising_Report event indicates that directed
 * advertisements have been received where the advertiser is using a resolvable
 * private address for the TargetA field of the advertising PDU which the
 * Controller is unable to resolve and the Scanning_Filter_Policy is equal to
 * 0x02 or 0x03. Direct_Address_Type and Direct_Address specify the address the
 * directed advertisements are being directed to. Address_Type and Address
 * specify the address of the advertiser sending the directed advertisements.
 * The Controller may queue these advertising reports and send information from
 * multiple advertisers in one HCI_LE_Directed_Advertising_Report event. This
 * event shall only be generated if scanning was enabled using the
 * HCI_LE_Set_Scan_Enable command. It only reports advertising events that used
 * legacy advertising PDUs.
 */
typedef PACKED(struct) hci_le_directed_advertising_report_event_rp0_s {
/**
 * Number of responses in this event.
 * Values:
 * - 0x01
 */
  uint8_t Num_Reports;
/**
 * See @ref packed_Direct_Advertising_Report_t
 */
  packed_Direct_Advertising_Report_t Direct_Advertising_Report[(HCI_MAX_PAYLOAD_SIZE - 1)/sizeof(packed_Direct_Advertising_Report_t)];
} hci_le_directed_advertising_report_event_rp0;

/**
 * The LE PHY Update Complete Event is used to indicate that the Controller has
 * changed the transmitter PHY or receiver PHY in use. If the Controller changes
 * the transmitter PHY, the receiver PHY, or both PHYs, this event shall be
 * issued. If an LE_Set_PHY command was sent and the Controller determines that
 * neither PHY will change as a result, it issues this event immediately.
 */
typedef PACKED(struct) hci_le_phy_update_complete_event_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
/**
 * Connection_Handle to be used to identify a connection.
 */
  uint16_t Connection_Handle;
/**
 * The transmitter PHY for the connection
 * Values:
 * - 0x01: The transmitter PHY for the connection is LE 1M
 * - 0x02: The transmitter PHY for the connection is LE 2M
 * - 0x03: The transmitter PHY for the connection is LE Coded
 */
  uint8_t TX_PHY;
/**
 * The receiver PHY for the connection
 * Values:
 * - 0x01: The receiver PHY for the connection is LE 1M
 * - 0x02: The receiver PHY for the connection is LE 2M
 * - 0x03: The receiver PHY for the connection is LE Coded
 */
  uint8_t RX_PHY;
} hci_le_phy_update_complete_event_rp0;

/**
 * The LE Extended Advertising Report event indicates that one or more Bluetooth
 * devices have responded to an active scan or have broadcast advertisements
 * that were received during a passive scan. The Controller may coalesce
 * multiple advertising reports from the same or different advertisers into a
 * single LE Extended Advertising Report event, provided all the parameters from
 * all the advertising reports fit in a single HCI event. This event shall only
 * be generated if scanning was enabled using the LE Set Extended Scan Enable
 * command. It reports advertising events using either legacy or extended
 * advertising PDUs. The Controller may split the data from a single
 * advertisement (whether one PDU or several) into several reports. If so, each
 * report except the last shall have an Event_Type with a data status field of
 * "incomplete, more data to come", while the last shall have the value
 * "complete"; the Address_Type, Address, Advertising_SID, Primary_PHY, and
 * Secondary_PHY fields shall be the same in all the reports. When a scan
 * response is received, bits 0-2 and 4 of the event type shall indicate the
 * properties of the original advertising event. An Event_Type with a data
 * status field of "incomplete, data truncated" indicates that the Controller
 * attempted to receive an AUX_CHAIN_IND PDU but was not successful.
 */
typedef PACKED(struct) hci_le_extended_advertising_report_event_rp0_s {
/**
 * Number of separate reports in the event
 * Values:
 * - 0x01 ... 0x0A
 */
  uint8_t Num_Reports;
/**
 * See @ref packed_Extended_Advertising_Report_t
 */
  packed_Extended_Advertising_Report_t Extended_Advertising_Report; /* N elements of variable size */
} hci_le_extended_advertising_report_event_rp0;

/**
 * The LE Periodic Advertising Report event indicates that the Controller has
 * received a Periodic Advertising packet. The Sync_Handle parameter indicates
 * the identifier for the periodic advertisements specified by the Advertising
 * SID subfield of the ADI field in the ADV_EXT_IND PDU. The Controller may
 * split the data from a single periodic advertisement (whether one PDU or
 * several) into several reports. If so, each report except the last shall have
 * a Data_Status of "incomplete, more data to come", while the last shall have
 * the value "complete". A Data_Status of "incomplete, data truncated" indicates
 * that the Controller attempted to receive an AUX_CHAIN_IND PDU but was not
 * successful. The Unused parameter shall be set to 0xFF by the Controller and
 * ignored by the Host.
 */
typedef PACKED(struct) hci_le_periodic_advertising_sync_established_event_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
/**
 * Sync handle that identifies the synchronization information about the
 * periodic advertising train.
 * Values:
 * - 0x0000 ... 0x0EFF
 */
  uint16_t Sync_Handle;
/**
 * Advertising SID subfield in the ADI field of the PDU
 * Values:
 * - 0x00 ... 0x0F: Value of the Advertising SID subfield in the ADI field of the PDU
 * - 0x10 ... 0xFF: Reserved for future use
 */
  uint8_t Advertising_SID;
/**
 * Advertising Address Type
 * Values:
 * - 0x00: Public Device Address
 * - 0x01: Random Device Address
 * - 0x02: Public Identity Address (corresponds to Resolved Private Address)
 * - 0x03: Random (static) Identity Address (corresponds to Resolved PrivateAddress)
 */
  uint8_t Advertiser_Address_Type;
/**
 * Public Device Address, Random Device Address, Public Identity Address, or
 * Random (static) Identity Address of the advertiser
 */
  uint8_t Advertiser_Address[6];
/**
 * Advertiser PHY
 * Values:
 * - 0x01: Advertiser PHY is LE 1M
 * - 0x02: Advertiser PHY is LE 2M
 * - 0x03: Advertiser PHY is LE Coded
 * - 0x04 ... 0xFF: Reserved for future use
 */
  uint8_t Advertiser_PHY;
/**
 * Periodic Advertising Interval Time = N * 1.25 ms Time Range: 7.5 ms to
 * 81.91875 s
 * Values:
 * - 0x0006 (7.50 ms)  ... 0xFFFF (NaN)
 */
  uint16_t Periodic_Advertising_Interval;
/**
 * Advertiser Clock Accuracy
 * Values:
 * - 0x00: 500 ppm
 * - 0x01: 250 ppm
 * - 0x02: 150 ppm
 * - 0x03: 100 ppm
 * - 0x04: 75 ppm
 * - 0x05: 50 ppm
 * - 0x06: 30 ppm
 * - 0x07: 20 ppm
 * - 0x08 ... 0xFF: Reserved for future use
 */
  uint8_t Advertiser_Clock_Accuracy;
} hci_le_periodic_advertising_sync_established_event_rp0;

/**
 * The LE Periodic Advertising Report event indicates that the Controller has
 * received a Periodic Advertising packet. The Sync_Handle parameter indicates
 * the identifier for the periodic advertisements specified by the Advertising
 * SID subfield of the ADI field in the ADV_EXT_IND PDU. The Controller may
 * split the data from a single periodic advertisement (whether one PDU or
 * several) into several reports. If so, each report except the last shall have
 * a Data_Status of "incomplete, more data to come", while the last shall have
 * the value "complete". A Data_Status of "incomplete, data truncated" indicates
 * that the Controller attempted to receive an AUX_CHAIN_IND PDU but was not
 * successful. The Unused parameter shall be set to 0xFF by the Controller and
 * ignored by the Host.
 */
typedef PACKED(struct) hci_le_periodic_advertising_report_event_rp0_s {
/**
 * Sync handle that identifies the synchronization information about the
 * periodic advertising train.
 * Values:
 * - 0x0000 ... 0x0EFF
 */
  uint16_t Sync_Handle;
/**
 * TX Power. Units: dBm
 * Values:
 * - -127 ... 126
 * - 127: NA
 */
  int8_t TX_Power;
/**
 * RSSI value Units: dBm
 * Values:
 * - -127 ... 20: RSSI value
 * - 127: RSSI is not available
 */
  int8_t RSSI;
/**
 *
 * Values:
 * - 0x00: AoA Constant Tone Extension
 * - 0x01: AoD Constant Tone Extension with 1 microsecond slots
 * - 0x02: AoD Constant Tone Extension with 2 microseconds slots
 * - 0xFF: No Constant Tone Extension
 */
  uint8_t CTE_Type;
/**
 * Data Status
 * Values:
 * - 0x00: Data complete
 * - 0x01: Data incomplete, more data to come
 * - 0x02: Data incomplete, data truncated, no more to come
 * - 0x03 ... 0xFF: Reserved for future use
 */
  uint8_t Data_Status;
/**
 * Length of the Data field
 * Values:
 * - 0 ... 247: Length of the Data field
 * - 248 ... 255: Reserved for future use
 */
  uint8_t Data_Length;
/**
 * Data received from a Periodic Advertising packet
 */
  uint8_t Data[(HCI_MAX_PAYLOAD_SIZE - 7)/sizeof(uint8_t)];
} hci_le_periodic_advertising_report_event_rp0;

/**
 * The LE Periodic Advertising Sync Lost event indicates that the Controller has
 * not received a Periodic Advertising packet identified by Sync_Handle within
 * the timeout period.
 */
typedef PACKED(struct) hci_le_periodic_advertising_sync_lost_event_rp0_s {
/**
 * Sync handle that identifies the synchronization information about the
 * periodic advertising train.
 * Values:
 * - 0x0000 ... 0x0EFF
 */
  uint16_t Sync_Handle;
} hci_le_periodic_advertising_sync_lost_event_rp0;

/**
 * The LE Advertising Set Terminated event indicates that the Controller has
 * terminated advertising in the advertising sets specified by the
 * Advertising_Handle parameter. This event shall be generated every time
 * connectable advertising in an advertising set results in a connection being
 * created. This event shall only be generated if advertising was enabled using
 * the LE Set Extended Advertising Enable command. The Connection_Handle
 * parameter is only valid when advertising ends because a connection was
 * created. If the Max_Extended_Advertising_Events parameter in the
 * LE_Set_Extended_Advertising_Enable command was non-zero, the
 * Num_Completed_Extended_Advertising_Events parameter shall be set to the
 * number of completed extended advertising events the Controller had
 * transmitted when either the duration elapsed or the maximum number of
 * extended advertising events was reached; otherwise it shall be set to zero.
 * If advertising has terminated as a result of the advertising duration
 * elapsing, the Status parameter shall be set to the error code Advertising
 * Timeout (0x3C). If advertising has terminated because the
 * Max_Extended_Advertising_Events was reached, the Status parameter shall be
 * set to the error code Limit Reached (0x43).
 */
typedef PACKED(struct) hci_le_advertising_set_terminated_event_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
/**
 * Advertising handle in which advertising has ended
 * Values:
 * - 0x00 ... 0xEF: Advertising_Handle in which advertising has ended
 * - 0xF0 ... 0xFF: Reserved for future use
 */
  uint8_t Advertising_Handle;
/**
 * Connection_Handle to be used to identify a connection.
 */
  uint16_t Connection_Handle;
/**
 * Number of completed extended advertising events transmitted by the Controller
 */
  uint8_t Num_Completed_Extended_Advertising_Events;
} hci_le_advertising_set_terminated_event_rp0;

/**
 * The LE Scan Request Received event indicates that a SCAN_REQ PDU or an
 * AUX_SCAN_REQ PDU has been received by the advertiser. The request contains a
 * device address from a scanner that is allowed by the advertising filter
 * policy. The advertising set is identified by Advertising_Handle. This event
 * shall only be generated if advertising was enabled using the LE Set Extended
 * Advertising Enable command. The Scanner_Address_Type and Scanner_Address
 * indicates the type of the address and the address of the scanner device.
 */
typedef PACKED(struct) hci_le_scan_request_received_event_rp0_s {
/**
 * It is used to identify an advertising set
 * Values:
 * - 0x00 ... 0xEF: Used to identify an advertising set
 * - 0xF0 ... 0xFF: Reserved for future use
 */
  uint8_t Advertising_Handle;
/**
 * Scanner address  type
 * Values:
 * - 0x00: Public Device Address
 * - 0x01: Random Device Address
 * - 0x02: Public Identity Address (corresponds to Resolved Private Address)
 * - 0x03: Random (static) Identity Address (corresponds to Resolved Private
Address)
 * - 0x04 ... 0xFF: Reserved for future use
 */
  uint8_t Scanner_Address_Type;
/**
 * Public Device Address, Random Device Address, Public Identity Address or
 * Random (static) Identity Address of the advertising device
 */
  uint8_t Scanner_Address[6];
} hci_le_scan_request_received_event_rp0;

/**
 * The LE Channel Selection Algorithm Event indicates which channel selection
 * algorithm is used on a data channel connection (see [Vol 6] Part B, Section
 * 4.5.8).
 */
typedef PACKED(struct) hci_le_channel_selection_algorithm_event_rp0_s {
/**
 * Connection_Handle to be used to identify a connection.
 */
  uint16_t Connection_Handle;
/**
 * Channel selection algorithm to be  used on a data channel connection
 * Values:
 * - 0x00: LE Channel Selection Algorithm #1 is used
 * - 0x01: LE Channel Selection Algorithm #2 is used
 * - 0x02 ... 0xFF: Reserved for future use
 */
  uint8_t Channel_Selection_Algorithm;
} hci_le_channel_selection_algorithm_event_rp0;

/**
 * The HCI_LE_Connectionless_IQ_Report event is used by the Controller to report
 * IQ information from the Constant Tone Extension of a received advertising
 * packet forming part of the periodic advertising train identified by
 * Sync_Handle and to report IQ information from the Constant Tone Extension of
 * a received Test Mode packet (see Section 7.8.28). The index of the channel on
 * which the packet was received, the RSSI of the packet (excluding the Constant
 * Tone Extension), the ID of the antenna on which this was measured, the type
 * of Constant Tone Extension, the value of paEventCounter, and the IQ samples
 * of the Constant Tone Extension of the advertisement are reported in the
 * corresponding parameters. For any given sample, either both or neither of
 * I_Sample[i] and Q_Sample[i] shall equal 0x80. The Slot_Durations parameter
 * specifies the sampling rate used by the Controller. The Packet_Status
 * parameter indicates whether the received packet had a valid CRC and, if not,
 * whether the Controller has determined the position and size of the Constant
 * Tone Extension using the Length and CTETime fields. Note: A Controller is not
 * required to generate this event for packets that have a bad CRC. The Constant
 * Tone Extension format is defined in [Vol 6] Part B, Section 2.5.1. If the PDU
 * contains AdvData, then the HCI_LE_Periodic_Advertising_Report event shall be
 * generated before this event. The Controller is not required to generate this
 * event for a Constant Tone Extension with a type that it does not support.
 * This event is also used by the Controller to report that it has insufficient
 * resources to report IQ samples for all received Constant Tone Extensions and
 * has failed to sample at least once. In this case Packet_Status shall be set
 * to 0xFF and Sample_Count to 0x00.
 */
typedef PACKED(struct) hci_le_connectionless_iq_report_event_rp0_s {
/**
 * Sync_Handle identifying the periodic advertising train.
 * Values:
 * - 0x0000 ... 0x0EFF
 * - 0x0FFF: TEST_SYNC_HANDLE
 */
  uint16_t Sync_Handle;
/**
 * 0x25-0x27 can be used only for packets generated during test modes.
 * Values:
 * - 0x00 ... 0x27: The index of the channel on which the packet was received.
 */
  uint8_t Channel_Index;
/**
 * RSSI of the packet. Units: 0.1 dBm.
 * Values:
 * - -1270 ... 200
 */
  int16_t RSSI;
/**
 * Antenna ID
 */
  uint8_t RSSI_Antenna_ID;
/**
 * Type of Constant Tone Extension.
 * Values:
 * - 0x00: AoA_CTE
 * - 0x01: AoD_CTE_1us
 * - 0x02: AoD_CTE_2us
 */
  uint8_t CTE_Type;
/**
 * Sampling rate used by the Controller.
 * Values:
 * - 0x01: CTE_SLOT_1us
 * - 0x02: CTE_SLOT_2us
 */
  uint8_t Slot_Durations;
/**
 * It indicates whether the received packet had a valid CRC and, if not, whether
 * the Controller has determined the position and size of the Constant Tone
 * Extension using the Length and CTETime fields. 0x00 - CRC was correct;  0x01
 * - CRC was incorrect and the Length and CTETime fields of the packet were used
 * to determine sampling points;  0x02 - CRC was incorrect but the Controller
 * has determined the position and length of the Constant Tone Extension in some
 * other way;  0xFF - Insufficient resources to sample (Channel_Index, CTE_Type,
 * and Slot_Durations invalid).
 * Values:
 * - 0x00: CRC_OK
 * - 0x01: CRC_ERROR_1
 * - 0x02: CRC_ERROR_2
 * - 0xFF: NO_SAMPLES
 */
  uint8_t Packet_Status;
/**
 * The value of paEventCounter (see [Vol 6] Part B, Section 4.4.2.1) for the
 * reported AUX_SYNC_IND PDU
 */
  uint16_t Periodic_Event_Counter;
/**
 * Total number of sample pairs (there shall be the same number of I samples and
 * Q samples). Note: This number is dependent on the switch and sample slot
 * durations used.
 * Values:
 * - 0x00
 * - 0x09 ... 0x52
 */
  uint8_t Sample_Count;
/**
 * See @ref packed_Samples_t
 */
  packed_Samples_t Samples[(HCI_MAX_PAYLOAD_SIZE - 12)/sizeof(packed_Samples_t)];
} hci_le_connectionless_iq_report_event_rp0;

/**
 * The HCI_LE_Connection_IQ_Report event is used by the Controller to report the
 * IQ samples from the Constant Tone Extension of a received packet (see [Vol 6]
 * Part B, Section 2.4.2.26). The Connection_Handle parameter identifies the
 * connection that corresponds to the reported information. The receiver PHY,
 * the index of the data channel, the RSSI value of the packet (excluding the
 * Constant Tone Extension), the ID of the antenna on which this was measured,
 * the type of Constant Tone Extension, the value of connEventCounter, and the
 * IQ samples of the Constant Tone Extension of the received packet are reported
 * in the corresponding parameters. For any given sample, either both or neither
 * of I_Sample[i] and Q_Sample[i] shall equal 0x80. The Slot_Durations parameter
 * specifies the sampling rate used by the Controller. The Packet_Status
 * parameter indicates whether the received packet had a valid CRC and, if not,
 * whether the Controller has determined the position and size of the Constant
 * Tone Extension using the Length and CTETime fields. Note: A Controller is not
 * required to generate this event for packets that have a bad CRC. This event
 * is also used by the Controller to report that it has insufficient resources
 * to report IQ samples for all received Constant Tone Extensions and has failed
 * to sample at least once. In this case Packet_Status shall be set to 0xFF and
 * Sample_Count to 0x00. The Constant Tone Extension format is defined in [Vol
 * 6] Part B, Section 2.1.5.
 */
typedef PACKED(struct) hci_le_connection_iq_report_event_rp0_s {
/**
 * Connection handle that identifies the connection.
 * Values:
 * - 0x0000 ... 0x0EFF
 */
  uint16_t Connection_Handle;
/**
 *
 * Values:
 * - 0x01: The receiver PHY for the connection is LE 1M
 * - 0x02: The receiver PHY for the connection is LE 2M
 */
  uint8_t RX_PHY;
/**
 *
 * Values:
 * - 0x00 ... 0x24: The index of the data channel on which the Data Physical Channel PDU was received.
 */
  uint8_t Data_Channel_Index;
/**
 * RSSI of the packet. Units: 0.1 dBm.
 * Values:
 * - -1270 ... 200
 */
  int16_t RSSI;
/**
 * ID of the antenna on which the RSSI is measured
 */
  uint8_t RSSI_Antenna_ID;
/**
 *
 * Values:
 * - 0x00: AoA Constant Tone Extension
 * - 0x01: AoD Constant Tone Extension with 1 microsecond slots
 * - 0x02: AoD Constant Tone Extension with 2 microseconds slots
 */
  uint8_t CTE_Type;
/**
 * Sampling rate used by the Controller.
 * Values:
 * - 0x01: CTE_SLOT_1us
 * - 0x02: CTE_SLOT_2us
 */
  uint8_t Slot_Durations;
/**
 *
 * Values:
 * - 0x00: CRC was correct
 * - 0x01: CRC was incorrect and the Length and CTETime fields of the packet were used to determine sampling points
 * - 0x02: CRC was incorrect but the Controller has determined the position and length of the Constant Tone Extension in some other way
 * - 0xFF: Insufficient resources to sample (Channel_Index, CTE_Type, and Slot_Durations invalid).
 */
  uint8_t Packet_Status;
/**
 * The value of connEventCounter (see [Vol 6] Part B, Section 4.5.1) for the
 * reported PDU
 */
  uint16_t Connection_Event_Counter;
/**
 * Total number of sample pairs.
 * Values:
 * - 0x00
 * - 0x09 ... 0x52
 */
  uint8_t Sample_Count;
/**
 * See @ref packed_Samples_t
 */
  packed_Samples_t Samples[(HCI_MAX_PAYLOAD_SIZE - 13)/sizeof(packed_Samples_t)];
} hci_le_connection_iq_report_event_rp0;

/**
 * This event is used by the Controller to report an issue following a request
 * to a peer device to reply with a packet containing an LL_CTE_RSP PDU and a
 * Constant Tone Extension. It shall be generated if the packet containing the
 * LL_CTE_RSP PDU sent in response did not contain a Constant Tone Extension or
 * if the peer rejected the request. It shall not be generated if the packet
 * containing the LL_CTE_RSP PDU had a CRC error or if the procedure response
 * timeout timer (see [Vol 6] Part B, Section 5.2) expired.
 */
typedef PACKED(struct) hci_le_cte_request_failed_event_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
/**
 * Connection handle that identifies the connection.
 * Values:
 * - 0x0000 ... 0x0EFF
 */
  uint16_t Connection_Handle;
} hci_le_cte_request_failed_event_rp0;

/**
 * The HCI_LE_Periodic_Advertising_Sync_Transfer_Received event is used by the
 * Controller to report that it has received periodic advertising
 * synchronization information from the device referred to by the
 * Connection_Handle parameter and either successfully synchronized to the
 * periodic advertising train or timed out while attempting to synchronize. The
 * Status will be zero if it successfully synchronized and non-zero otherwise.
 * The Service_Data value is provided by the Host of the device sending the
 * information. The Sync_Handle identifies the periodic advertising in
 * subsequent commands and events and shall be assigned by the Controller. The
 * remaining parameters provide information about the periodic advertising (see
 * Section 7.7.65.14). If Status is non-zero, all parameter values are valid
 * except Sync_Handle, which the Host shall ignore. Note: If the Controller is
 * already synchronized to the periodic advertising train described in the
 * received information, no event will be generated.
 */
typedef PACKED(struct) hci_le_periodic_advertising_sync_transfer_received_event_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
/**
 * Connection handle that identifies the connection.
 * Values:
 * - 0x0000 ... 0x0EFF
 */
  uint16_t Connection_Handle;
/**
 * A value provided by the peer device
 */
  uint16_t Service_data;
/**
 * Sync handle that identifies the synchronization information about the
 * periodic advertising train.
 * Values:
 * - 0x0000 ... 0x0EFF
 */
  uint16_t Sync_Handle;
/**
 *
 * Values:
 * - 0x00 ... 0x0F: Value of the Advertising SID used to advertise the periodic advertising
 */
  uint8_t Advertising_SID;
/**
 *
 * Values:
 * - 0x00: Public Device Address
 * - 0x01: Random Device Address
 * - 0x02: Public Identity Address (corresponds to Resolved Private Address)
 * - 0x03: Random (static) Identity Address (corresponds to Resolved Private Address)
 */
  uint8_t Advertiser_Address_Type;
/**
 * Public Device Address, Random Device Address, Public Identity Address, or
 * Random (static) Identity Address of the advertiser
 */
  uint8_t Advertiser_Address[6];
/**
 *
 * Values:
 * - 0x01: Advertiser PHY is LE 1M
 * - 0x02: Advertiser PHY is LE 2M
 * - 0x03: Advertiser PHY is LE Coded
 */
  uint8_t Advertiser_PHY;
/**
 * Periodic advertising interval. Time = N * 1.25 ms; Time Range: 7.5ms to
 * 81.91875 s.
 * Values:
 * - 0x0006 (7.50 ms)  ... 0xFFFF (NaN)
 */
  uint16_t Periodic_Advertising_Interval;
/**
 * Advertiser Clock Accuracy
 * Values:
 * - 0x00: 500 ppm
 * - 0x01: 250 ppm
 * - 0x02: 150 ppm
 * - 0x03: 100 ppm
 * - 0x04: 75 ppm
 * - 0x05: 60 ppm
 * - 0x06: 30 ppm
 * - 0x07: 20 ppm
 */
  uint8_t Advertiser_Clock_Accuracy;
} hci_le_periodic_advertising_sync_transfer_received_event_rp0;

/**
 * The HCI_LE_CIS_Established event indicates that a CIS has been established,
 * was considered lost before being established, or (on the Central) was
 * rejected by the Peripheral. It is generated by the Controller in the Central
 * and Peripheral. The Connection_Handle parameter shall be set to the value
 * provided in the HCI_LE_Create_CIS command on the Central and in the
 * HCI_LE_CIS_Request event on the Peripheral. The CIG_Sync_Delay parameter is
 * the maximum time, in microseconds, for transmission of PDUs of all CISes in a
 * CIG event (see [Vol 6] Part B, Section 4.5.14.1). The CIS_Sync_Delay
 * parameter is the maximum time, in microseconds, for transmission of PDUs of
 * the specified CIS in a CIG event (see [Vol 6] Part B, Section 4.5.14.1). The
 * Transport_Latency_C_To_P and Transport_Latency_P_To_C parameters are the
 * actual transport latencies, in microseconds, as described in [Vol 6] Part G,
 * Section 3.2.1 and [Vol 6] Part G, Section 3.2.2. The PHY_C_To_P parameter
 * indicates the PHY selected for packets from the Central to Peripheral. The
 * PHY_P_To_C parameter indicates the PHY selected for packets from the
 * Peripheral to Central. The NSE, BN_C_To_P, BN_P_To_C, FT_C_To_P, FT_P_To_C,
 * Max_PDU_- C_To_P, Max_PDU_P_To_C, and ISO_Interval parameters are the
 * corresponding parameters of the CIS (see [Vol 6] Part B, Section 4.5.13.1).
 * If this event is generated on the Peripheral with a non-zero status, the
 * Controller shall delete the Connection_Handle and any associated ISO data
 * paths.
 */
typedef PACKED(struct) hci_le_cis_established_event_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
/**
 * Connection handle of the CIS.
 * Values:
 * - 0x0000 ... 0x0EFF
 */
  uint16_t Connection_Handle;
/**
 * The maximum time, in microseconds, for transmission of PDUs of all CISes in a
 * CIG event.
 * Values:
 * - 0x0000EA ... 0x7FFFFF
 */
  uint8_t CIG_Sync_Delay[3];
/**
 * The maximum time, in microseconds, for transmission of PDUs of the specified
 * CIS in a CIG event.
 * Values:
 * - 0x0000EA ... 0x7FFFFF
 */
  uint8_t CIS_Sync_Delay[3];
/**
 * The actual transport latency, in microseconds, from Central to Peripheral.
 * Values:
 * - 0x0000EA ... 0x7FFFFF
 */
  uint8_t Transport_Latency_C_To_P[3];
/**
 * The actual transport latency, in microseconds, from Peripheral to Central.
 * Values:
 * - 0x0000EA ... 0x7FFFFF
 */
  uint8_t Transport_Latency_P_To_C[3];
/**
 * The transmitter PHY of packets from the Central.
 * Values:
 * - 0x01: LE_1M_PHY
 * - 0x02: LE_2M_PHY
 * - 0x03: LE_CODED_PHY
 */
  uint8_t PHY_C_To_P;
/**
 * The transmitter PHY of packets from the Peripheral.
 * Values:
 * - 0x01: LE_1M_PHY
 * - 0x02: LE_2M_PHY
 * - 0x03: LE_CODED_PHY
 */
  uint8_t PHY_P_To_C;
/**
 * Maximum number of subevents in each isochronous event.
 * Values:
 * - 0x01 ... 0x1F
 */
  uint8_t NSE;
/**
 * The burst number for Central to Peripheral transmission.
 * Values:
 * - 0x00: No data
 * - 0x01 ... 0x0F
 */
  uint8_t BN_C_To_P;
/**
 * The burst number for Peripheral to Central transmission.
 * Values:
 * - 0x00: No data
 * - 0x01 ... 0x0F
 */
  uint8_t BN_P_To_C;
/**
 * The flush timeout, in multiples of the ISO_Interval for the CIS, for each
 * payload sent from the Central to the Peripheral.
 * Values:
 * - 0x01 ... 0xFF
 */
  uint8_t FT_C_To_P;
/**
 * The flush timeout, in multiples of the ISO_Interval for the CIS, for each
 * payload sent from the Peripheral to the Central.
 * Values:
 * - 0x01 ... 0xFF
 */
  uint8_t FT_P_To_C;
/**
 * Maximum size, in octets, of the payload from Central to Peripheral.
 * Values:
 * - 0x0000 ... 0x00FB
 */
  uint16_t Max_PDU_C_To_P;
/**
 * Maximum size, in octets, of the payload from Peripheral to Central.
 * Values:
 * - 0x0000 ... 0x00FB
 */
  uint16_t Max_PDU_P_To_C;
/**
 * The time between two consecutive CIS anchor points. Time = N * 1.25 ms.
 * Values:
 * - 0x0004 (5.00 ms)  ... 0x0C80 (4000.00 ms)
 */
  uint16_t ISO_Interval;
} hci_le_cis_established_event_rp0;

/**
 * The HCI_LE_CIS_Request event indicates that a Controller has received a
 * request to establish a CIS. If the Controller receives such a request while
 * the HCI_LE_CIS_Request event is masked away, it shall reject it. Otherwise
 * the Controller shall assign a connection handle for the requested CIS and
 * send the handle in the CIS_Connection_Handle parameter of the event. When the
 * Host receives this event it shall respond with either an
 * HCI_LE_Accept_CIS_Request command or an HCI_LE_Reject_CIS_Request command
 * before the timer Connection_Accept_Timeout expires. If it does not, the
 * Controller shall reject the request and generate an HCI_LE_CIS_Established
 * event with the status Connection Accept Timeout Exceeded (0x10). The
 * ACL_Connection_Handle is the connection handle of the ACL connection that is
 * associated with the requested CIS. The CIG_ID parameter contains the
 * identifier of the CIG that contains the requested CIS. This parameter is sent
 * by the Central in the request to establish the CIS. The CIS_ID parameter
 * contains the identifier of the requested CIS. This parameter is sent by the
 * Central in the request to establish the CIS.
 */
typedef PACKED(struct) hci_le_cis_request_event_rp0_s {
/**
 * Connection handle of the ACL.
 * Values:
 * - 0x0000 ... 0x0EFF
 */
  uint16_t ACL_Connection_Handle;
/**
 * Connection handle of the CIS.
 * Values:
 * - 0x0000 ... 0x0EFF
 */
  uint16_t CIS_Connection_Handle;
/**
 * Identifier of the CIG.
 * Values:
 * - 0x00 ... 0xEF
 */
  uint8_t CIG_ID;
/**
 * Identifier of the CIS.
 * Values:
 * - 0x00 ... 0xEF
 */
  uint8_t CIS_ID;
} hci_le_cis_request_event_rp0;

/**
 * The HCI_LE_Create_BIG_Complete event indicates that the HCI_LE_Create_BIG
 * command has completed.
 */
typedef PACKED(struct) hci_le_create_big_complete_event_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
/**
 * The identifier of the BIG.
 * Values:
 * - 0x00 ... 0xEF
 */
  uint8_t BIG_Handle;
/**
 * The maximum time in microseconds for transmission of PDUs of all BISes in a
 * BIG event.
 * Values:
 * - 0x0000EA ... 0x7FFFFF
 */
  uint8_t BIG_Sync_Delay[3];
/**
 * The maximum delay time, in microseconds, for transmission of SDUs of all
 * BISes in a BIG event.
 * Values:
 * - 0x0000EA ... 0x7FFFFF
 */
  uint8_t Transport_Latency_BIG[3];
/**
 * The PHY used to create the BIG.
 * Values:
 * - 0x01: LE_1M_PHY
 * - 0x02: LE_2M_PHY
 * - 0x03: LE_CODED_PHY
 */
  uint8_t PHY;
/**
 * The number of subevents in each BIS event in the BIG.
 * Values:
 * - 0x01 ... 0x1E
 */
  uint8_t NSE;
/**
 * The number of new payloads in each BIS event.
 * Values:
 * - 0x01 ... 0x07
 */
  uint8_t BN;
/**
 * Offset used for pre-transmissions.
 * Values:
 * - 0x00 ... 0x0F
 */
  uint8_t PTO;
/**
 * The number of times a payload is transmitted in a BIS event.
 * Values:
 * - 0x01 ... 0x0F
 */
  uint8_t IRC;
/**
 * Maximum size, in octets, of the payload.
 * Values:
 * - 0x0000 ... 0x00FB
 */
  uint16_t Max_PDU;
/**
 * The time between two consecutive BIG anchor points. Time = N * 1.25 ms.
 * Values:
 * - 0x0004 (5.00 ms)  ... 0x0C80 (4000.00 ms)
 */
  uint16_t ISO_Interval;
/**
 * Total number of BISes in the BIG.
 * Values:
 * - 0x01 ... 0x1F
 */
  uint8_t Num_BIS;
/**
 * The connection handles of the BISes in the BIG.
 */
  uint16_t Connection_Handle[(HCI_MAX_PAYLOAD_SIZE - 18)/sizeof(uint16_t)];
} hci_le_create_big_complete_event_rp0;

/**
 * The HCI_LE_Terminate_BIG_Complete event indicates that the transmission of
 * all the BISes in the BIG are terminated.
 */
typedef PACKED(struct) hci_le_terminate_big_complete_event_rp0_s {
/**
 * The identifier of the BIG.
 * Values:
 * - 0x00 ... 0xEF
 */
  uint8_t BIG_Handle;
/**
 * Reason for termination. See Error Codes.
 */
  uint8_t Reason;
} hci_le_terminate_big_complete_event_rp0;

/**
 * The HCI_LE_BIG_Sync_Established event indicates that the
 * HCI_LE_BIG_Create_Sync command has completed.
 */
typedef PACKED(struct) hci_le_big_sync_established_event_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
/**
 * The identifier of the BIG.
 * Values:
 * - 0x00 ... 0xEF
 */
  uint8_t BIG_Handle;
/**
 * The maximum delay time, in microseconds, for transmission of SDUs of all
 * BISes in a BIG event.
 * Values:
 * - 0x0000EA ... 0x7FFFFF
 */
  uint8_t Transport_Latency_BIG[3];
/**
 * The number of subevents in each BIS event in the BIG.
 * Values:
 * - 0x01 ... 0x1E
 */
  uint8_t NSE;
/**
 * The number of new payloads in each BIS event.
 * Values:
 * - 0x01 ... 0x07
 */
  uint8_t BN;
/**
 * Offset used for pre-transmissions.
 * Values:
 * - 0x00 ... 0x0F
 */
  uint8_t PTO;
/**
 * The number of times a payload is transmitted in a BIS event.
 * Values:
 * - 0x01 ... 0x0F
 */
  uint8_t IRC;
/**
 * Maximum size, in octets, of the payload.
 * Values:
 * - 0x0000 ... 0x00FB
 */
  uint16_t Max_PDU;
/**
 * The time between two consecutive BIG anchor points. Time = N * 1.25 ms.
 * Values:
 * - 0x0004 (5.00 ms)  ... 0x0C80 (4000.00 ms)
 */
  uint16_t ISO_Interval;
/**
 * Total number of BISes in the BIG.
 * Values:
 * - 0x01 ... 0x1F
 */
  uint8_t Num_BIS;
/**
 * The connection handles of the BISes in the BIG.
 */
  uint16_t Connection_Handle[(HCI_MAX_PAYLOAD_SIZE - 14)/sizeof(uint16_t)];
} hci_le_big_sync_established_event_rp0;

/**
 * The HCI_LE_BIG_Sync_Lost event indicates that the Controller has not received
 * any PDUs on a BIG within the timeout period BIG_Sync_Timeout or the BIG has
 * been terminated by the remote device.
 */
typedef PACKED(struct) hci_le_big_sync_lost_event_rp0_s {
/**
 * The identifier of the BIG.
 * Values:
 * - 0x00 ... 0xEF
 */
  uint8_t BIG_Handle;
/**
 * Reason for termination. See Error Codes.
 */
  uint8_t Reason;
} hci_le_big_sync_lost_event_rp0;

/**
 * The HCI_LE_Request_Peer_SCA_Complete event indicates that the
 * HCI_LE_Request_Peer_SCA command has been completed. The Peer_Clock_Accuracy
 * parameter contains the sleep clock accuracy of the peer. The
 * Connection_Handle is the connection handle of the ACL connection in which the
 * HCI_LE_Request_Peer_SCA command is issued.
 */
typedef PACKED(struct) hci_le_request_peer_sca_complete_event_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
/**
 * Connection handle of the ACL.
 */
  uint16_t Connection_Handle;
/**
 * Sleep clock accuracy of the peer.
 * Values:
 * - 0x00: 251 ppm to 500 ppm
 * - 0x01: 151 ppm to 250 ppm
 * - 0x02: 101 ppm to 150 ppm
 * - 0x03: 76 ppm to 100 ppm
 * - 0x04: 51 ppm to 75 ppm
 * - 0x05: 31 ppm to 50 ppm
 * - 0x06: 21 ppm to 30 ppm
 * - 0x07: 0 ppm to 20 ppm
 */
  uint8_t Peer_Clock_Accuracy;
} hci_le_request_peer_sca_complete_event_rp0;

/**
 * Report a path loss threshold crossing on the ACL connection identified by the
 * Connection_Handle parameter.
 */
typedef PACKED(struct) hci_le_path_loss_threshold_event_rp0_s {
/**
 * Connection handle that identifies the connection.
 * Values:
 * - 0x0000 ... 0x0EFF
 */
  uint16_t Connection_Handle;
/**
 * Current path loss (always zero or positive). Units: dB.
 * Values:
 * - 0 ... 254
 * - 255: NA
 */
  uint8_t Current_Path_Loss;
/**
 * The Zone_Entered parameter indicates which zone was entered.
 * Values:
 * - 0x00: LOW_ZONE
 * - 0x01: MIDDLE_ZONE
 * - 0x02: HIGH_ZONE
 */
  uint8_t Zone_Entered;
} hci_le_path_loss_threshold_event_rp0;

/**
 * Report the transmit power level on the ACL connection identified by the
 * Connection_Handle parameter.
 */
typedef PACKED(struct) hci_le_transmit_power_reporting_event_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
/**
 * Connection handle that identifies the connection.
 * Values:
 * - 0x0000 ... 0x0EFF
 */
  uint16_t Connection_Handle;
/**
 * The reason why the event was sent and the device whose transmit power level
 * is being reported. - 0x00: Local transmit power changed - 0x01: Remote
 * transmit power changed - 0x02: HCI_LE_Read_Remote_Transmit_Power_Level
 * command completed
 * Values:
 * - 0x00: LOCAL_TX_POWER_CHANGE
 * - 0x01: REMOTE_TX_POWER_CHANGE
 * - 0x02: READ_REMOTE_TX_POWER_COMPLETE
 */
  uint8_t Reason;
/**
 * PHY associated with the connection  (not necessarily the currently used one).
 * Values:
 * - 0x01: LE_1M_PHY
 * - 0x02: LE_2M_PHY
 * - 0x03: LE_CODED_PHY_S8
 * - 0x04: LE_CODED_PHY_S2
 */
  uint8_t PHY;
/**
 * The transmit power level for the PHY (dBm).
 * Values:
 * - -127 ... 20
 * - 126: POWER_NOT_MANAGED
 * - 127: POWER_NA
 */
  int8_t Transmit_Power_Level;
/**
 * It indicates whether the transmit power level that is being reported has
 * reached its minimum and/or maximum level. Transmit_Power_Level_Flag shall be
 * ignored if the Transmit_Power_Level parameter is set to 0x7E or 0x7F.
 * Flags:
 * - 0x01: MIN_TX_POWER_BIT
 * - 0x02: MAX_TX_POWER_BIT
 */
  uint8_t Transmit_Power_Level_Flag;
/**
 * The Delta parameter is set to the change in power level for the transmitter
 * being reported, whenever it changes its transmit power level. Delta shall be
 * ignored if the Transmit_Power_Level parameter is set to 0x7E.
 * Values:
 * - 0 ... 126
 * - 127: NA
 */
  int8_t Delta;
} hci_le_transmit_power_reporting_event_rp0;

/**
 * The HCI_LE_BIGInfo_Advertising_Report event indicates that the Controller has
 * received an Advertising PDU that contained a BIGInfo field. If the Controller
 * also generates an HCI_LE_Periodic_Advertising_Report event, the
 * HCI_LE_BIGInfo_Advertising_Report event shall immediately follow that event.
 * An HCI_LE_BIGInfo_Advertising_Report event shall be generated even if the
 * Controller is already synchronized to the BIG. The Sync_Handle parameter
 * shall identify the periodic advertising train containing the BIGInfo field
 * and shall be the same as the corresponding field in the
 * HCI_LE_Periodic_Advertising_Report event if one is generated. The Num_BIS,
 * NSE, ISO_Interval, BN, PTO, IRC, Max_PDU, SDU_Interval, Max_SDU, PHY, and
 * Framing parameters correspond to the associated fields in the BIGInfo field
 * of the Advertising PDU. If the BIGInfo field indicates that the corresponding
 * BIG is encrypted, the Encryption parameter shall be set to 0x01. Otherwise,
 * the Encryption parameter shall be set to 0x00.
 */
typedef PACKED(struct) hci_le_biginfo_advertising_report_event_rp0_s {
/**
 * Sync_Handle identifying the periodic advertising train.
 * Values:
 * - 0x0000 ... 0x0EFF
 */
  uint16_t Sync_Handle;
/**
 * Value of the Num_BIS subfield of the BIGInfo field.
 * Values:
 * - 0x01 ... 0x1F
 */
  uint8_t Num_BIS;
/**
 * Value of the NSE subfield of the BIGInfo field.
 */
  uint8_t NSE;
/**
 * Value of the ISO_Interval subfield of the BIGInfo field.
 */
  uint16_t ISO_Interval;
/**
 * Value of the BN subfield of the BIGInfo field.
 * Values:
 * - 0x01 ... 0x07
 */
  uint8_t BN;
/**
 * Value of the PTO subfield of the BIGInfo field.
 * Values:
 * - 0x00 ... 0x0F
 */
  uint8_t PTO;
/**
 * Value of the IRC subfield of the BIGInfo field.
 * Values:
 * - 0x01 ... 0x0F
 */
  uint8_t IRC;
/**
 * Value of the Max_PDU subfield of the BIGInfo.
 * Values:
 * - 0x0000 ... 0x00FB
 */
  uint16_t Max_PDU;
/**
 * Value of the SDU_Interval subfield of the BIGInfo field.
 * Values:
 * - 0x0000FF ... 0x0FFFFF
 */
  uint8_t SDU_Interval[3];
/**
 * Value of the Max_SDU subfield of the BIGInfo field in the Advertising PDU.
 * Values:
 * - 0x0001 ... 0x0FFF
 */
  uint16_t Max_SDU;
/**
 * The PHY on which the BIG is transmitted.
 * Values:
 * - 0x01: LE_1M_PHY
 * - 0x02: LE_2M_PHY
 * - 0x03: LE_CODED_PHY
 */
  uint8_t PHY;
/**
 * If BIG carries encrypted (1) or unencrypted (0) data.
 * Values:
 * - 0x00: Unencrypted
 * - 0x01: Encrypted
 */
  uint8_t Framing;
/**
 * If BIG carries encrypted (1) or unencrypted (0) data.
 * Values:
 * - 0x00: Unencrypted
 * - 0x01: Encrypted
 */
  uint8_t Encryption;
} hci_le_biginfo_advertising_report_event_rp0;

/**
 * The HCI_LE_Subrate_Change event is used to indicate that a Connection Subrate
 * Update procedure has completed and some parameters of the specified
 * connection have changed. This event shall be issued if the
 * HCI_LE_Subrate_Request command was issued by the Host or the parameters are
 * updated successfully following a request from the peer device. If no
 * parameters are updated following a request from the peer device or the
 * parameters were changed using the Connection Update procedure, then this
 * event shall not be issued.
 */
typedef PACKED(struct) hci_le_subrate_change_event_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
/**
 * Handle identifying the connection.
 * Values:
 * - 0x0000 ... 0x0EFF
 */
  uint16_t Connection_Handle;
/**
 * New subrate factor applied to the specified underlying connection interval.
 * Values:
 * - 0x0001 ... 0x01F4
 */
  uint16_t Subrate_Factor;
/**
 * New Peripheral latency for the connection in number of subrated connection
 * events,
 * Values:
 * - 0x0000 ... 0x01F3
 */
  uint16_t Peripheral_Latency;
/**
 * Number of underlying connection events to remain active after a packet
 * containing a Link Layer PDU with a non-zero Length field is sent or received.
 * Values:
 * - 0x0000 ... 0x01F3
 */
  uint16_t Continuation_Number;
/**
 * New supervision timeout for this connection. Time = N x 10 ms.
 * Values:
 * - 0x000A (100 ms)  ... 0x0C80 (32000 ms)
 */
  uint16_t Supervision_Timeout;
} hci_le_subrate_change_event_rp0;

/**
 * The HCI_LE_Periodic_Advertising_Sync_Established event indicates that the
 * Controller has received the first periodic advertising packet from an
 * advertiser after the HCI_LE_Periodic_Advertising_Create_Sync command has been
 * sent to the Controller. The Sync_Handle parameter identifies the periodic
 * advertising train in subsequent commands and events and shall be assigned by
 * the Controller. The Advertising_SID parameter is set to the value of the
 * Advertising SID subfield in the ADI field of the advertising PDU referring to
 * the periodic advertising train. The Advertiser_Address_Type and
 * Advertiser_Address parameters specify the address of the periodic advertiser.
 * The Advertiser_PHY parameter specifies the PHY used for the periodic
 * advertising. The Periodic_Advertising_Interval parameter specifies the
 * interval between the periodic advertising events. The
 * Advertiser_Clock_Accuracy parameter specifies the accuracy of the periodic
 * advertiser's clock. If the periodic advertising has subevents or response
 * slots, then the Num_- Subevents, Subevent_Interval, Response_Slot_Delay, and
 * Response_Slot_- Spacing specify the parameters for these subevents, otherwise
 * these values shall be set to 0x00.
 */
typedef PACKED(struct) hci_le_periodic_advertising_sync_established_v2_event_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
/**
 * Sync handle that identifies the synchronization information about the
 * periodic advertising train.
 * Values:
 * - 0x0000 ... 0x0EFF
 */
  uint16_t Sync_Handle;
/**
 * Advertising SID subfield in the ADI field of the PDU
 * Values:
 * - 0x00 ... 0x0F: Value of the Advertising SID subfield in the ADI field of the PDU
 * - 0x10 ... 0xFF: Reserved for future use
 */
  uint8_t Advertising_SID;
/**
 * Advertising Address Type
 * Values:
 * - 0x00: Public Device Address
 * - 0x01: Random Device Address
 * - 0x02: Public Identity Address (corresponds to Resolved Private Address)
 * - 0x03: Random (static) Identity Address (corresponds to Resolved PrivateAddress)
 */
  uint8_t Advertiser_Address_Type;
/**
 * Public Device Address, Random Device Address, Public Identity Address, or
 * Random (static) Identity Address of the advertiser
 */
  uint8_t Advertiser_Address[6];
/**
 * Advertiser PHY
 * Values:
 * - 0x01: Advertiser PHY is LE 1M
 * - 0x02: Advertiser PHY is LE 2M
 * - 0x03: Advertiser PHY is LE Coded
 * - 0x04 ... 0xFF: Reserved for future use
 */
  uint8_t Advertiser_PHY;
/**
 * Periodic Advertising Interval Time = N * 1.25 ms Time Range: 7.5 ms to
 * 81.91875 s
 * Values:
 * - 0x0006 (7.50 ms)  ... 0xFFFF (NaN)
 */
  uint16_t Periodic_Advertising_Interval;
/**
 * Advertiser Clock Accuracy
 * Values:
 * - 0x00: 500 ppm
 * - 0x01: 250 ppm
 * - 0x02: 150 ppm
 * - 0x03: 100 ppm
 * - 0x04: 75 ppm
 * - 0x05: 50 ppm
 * - 0x06: 30 ppm
 * - 0x07: 20 ppm
 * - 0x08 ... 0xFF: Reserved for future use
 */
  uint8_t Advertiser_Clock_Accuracy;
/**
 * Number of subevents.
 * Values:
 * - 0x00 ... 0x80
 */
  uint8_t Num_Subevents;
/**
 * Subevent interval. Time = N x 1.25 ms.
 * Values:
 * - 0x00 (NaN) : No subevents
 * - 0x06 (7.50 ms)  ... 0xFF (318.75 ms)
 */
  uint8_t Subevent_Interval;
/**
 * Response slot delay. Range: 0x01 to 0xFE. Time = N x 1.25 ms
 * Values:
 * - 0x00 (NaN) : No response slots
 * - 0x01 (1.25 ms)  ... 0xFE (317.50 ms)
 */
  uint8_t Response_Slot_Delay;
/**
 * Response slot spacing Range: 0x02 to 0xFF Time = N x 0.125 ms
 * Values:
 * - 0x00 (0.000 ms) : No response slots
 * - 0x02 (0.250 ms)  ... 0xFF (31.875 ms)
 */
  uint8_t Response_Slot_Spacing;
} hci_le_periodic_advertising_sync_established_v2_event_rp0;

/**
 * The HCI_LE_Periodic_Advertising_Report event indicates that the Controller
 * has received a periodic advertisement or has failed to receive an
 * AUX_SYNC_SUBEVENT_IND PDU. The Sync_Handle parameter identifies the periodic
 * advertising train that the report relates to. The RSSI parameter contains the
 * RSSI value, excluding any Constant Tone Extension. If the Controller supports
 * the Connectionless CTE Receiver feature, RSSI shall not be set to 0x7F. When
 * multiple advertising packets are used to complete a periodic advertising
 * report (e.g., a packet containing an AUX_SYNC_IND PDU combined with one
 * containing an AUX_CHAIN PDU), the RSSI event parameter shall be set based on
 * the last packet received and the TX_Power event parameter shall be set based
 * on the AUX_SYNC_IND PDU. However, the second or subsequent events for the
 * same periodic advertisement may instead have a TX_Power value of 0x7F. The
 * Controller may split the data from a single periodic advertisement (whether
 * one PDU or several) into several reports. If so, each report except the last
 * shall have a Data_Status of "incomplete, more data to come", while the last
 * shall have the value "complete". No further reports shall be sent for a given
 * periodic advertisement after one with a Data_Status other than "incomplete,
 * more data to come". A Data_Status of "incomplete, data truncated" indicates
 * that the Controller attempted to receive an AUX_CHAIN_IND PDU but was not
 * successful or received it but was unable to store the data. The CTE_Type
 * parameter indicates the type of Constant Tone Extension in the periodic
 * advertising packets. The Periodic_Event_Counter parameter indicates the
 * periodic advertising event counter (paEventCounter) of the event that the
 * periodic advertising packet was received in. The Subevent parameter indicates
 * the Periodic Advertising with Responses subevent that the periodic
 * advertising packet was received in. If the Periodic Advertising does not have
 * subevents, then Subevent shall be set to 0xFF. If the Controller receives an
 * AUX_CHAIN_IND PDU with no AdvData, it should send the report (or the last
 * report if it has split the data) immediately without waiting for any
 * subsequent AUX_CHAIN_IND PDUs.
 */
typedef PACKED(struct) hci_le_periodic_advertising_report_v2_event_rp0_s {
/**
 * Sync handle that identifies the synchronization information about the
 * periodic advertising train.
 * Values:
 * - 0x0000 ... 0x0EFF
 */
  uint16_t Sync_Handle;
/**
 * TX Power. Units: dBm
 * Values:
 * - -127 ... 126
 * - 127: NA
 */
  int8_t TX_Power;
/**
 * RSSI value Units: dBm
 * Values:
 * - -127 ... 20: RSSI value
 * - 127: RSSI is not available
 */
  int8_t RSSI;
/**
 *
 * Values:
 * - 0x00: AoA Constant Tone Extension
 * - 0x01: AoD Constant Tone Extension with 1 microsecond slots
 * - 0x02: AoD Constant Tone Extension with 2 microseconds slots
 * - 0xFF: No Constant Tone Extension
 */
  uint8_t CTE_Type;
/**
 * The value of paEventCounter (see [Vol 6] Part B, Section 4.4.2.1) for the
 * reported periodic advertising packet.
 */
  uint16_t Periodic_Event_Counter;
/**
 * The subevent number.
 * Values:
 * - 0x00 ... 0x7F
 * - 0xFF: No subevents
 */
  uint8_t Subevent;
/**
 * Data Status
 * Values:
 * - 0x00: Data complete
 * - 0x01: Data incomplete, more data to come
 * - 0x02: Data incomplete, data truncated, no more to come
 * - 0xFF: Failed to receive an AUX_SYNC_SUBEVENT_IND PDU
 */
  uint8_t Data_Status;
/**
 * Length of the Data field
 * Values:
 * - 0 ... 247: Length of the Data field
 * - 248 ... 255: Reserved for future use
 */
  uint8_t Data_Length;
/**
 * Data received from a Periodic Advertising packet
 */
  uint8_t Data[(HCI_MAX_PAYLOAD_SIZE - 10)/sizeof(uint8_t)];
} hci_le_periodic_advertising_report_v2_event_rp0;

/**
 * The HCI_LE_Periodic_Advertising_Sync_Transfer_Received event is used by the
 * Controller to report that it has received periodic advertising
 * synchronization information from the device referred to by the
 * Connection_Handle parameter and either successfully synchronized to the
 * periodic advertising train or timed out while attempting to synchronize. The
 * Status will be zero if it successfully synchronized and non-zero otherwise.
 * The Service_Data value is provided by the Host of the device sending the
 * information. The Sync_Handle identifies the periodic advertising in
 * subsequent commands and events and shall be assigned by the Controller. The
 * remaining parameters provide information about the periodic advertising (see
 * Section 7.7.65.14). If there are no subevents or response slots, then the
 * Controller shall set the Num_Subevents parameter to zero and the Host shall
 * ignore the Subevent_Interval, Response_Slot_Delay, and Response_Slot_-
 * Spacing parameters. If Status is non-zero, all parameter values are valid
 * except Sync_Handle, which the Host shall ignore. Note: If the Controller is
 * already synchronized to the periodic advertising train described in the
 * received information, no event will be generated.
 */
typedef PACKED(struct) hci_le_periodic_advertising_sync_transfer_received_v2_event_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
/**
 * Connection handle that identifies the connection.
 * Values:
 * - 0x0000 ... 0x0EFF
 */
  uint16_t Connection_Handle;
/**
 * A value provided by the peer device
 */
  uint16_t Service_data;
/**
 * Sync handle that identifies the synchronization information about the
 * periodic advertising train.
 * Values:
 * - 0x0000 ... 0x0EFF
 */
  uint16_t Sync_Handle;
/**
 *
 * Values:
 * - 0x00 ... 0x0F: Value of the Advertising SID used to advertise the periodic advertising
 */
  uint8_t Advertising_SID;
/**
 *
 * Values:
 * - 0x00: Public Device Address
 * - 0x01: Random Device Address
 * - 0x02: Public Identity Address (corresponds to Resolved Private Address)
 * - 0x03: Random (static) Identity Address (corresponds to Resolved Private Address)
 */
  uint8_t Advertiser_Address_Type;
/**
 * Public Device Address, Random Device Address, Public Identity Address, or
 * Random (static) Identity Address of the advertiser
 */
  uint8_t Advertiser_Address[6];
/**
 *
 * Values:
 * - 0x01: Advertiser PHY is LE 1M
 * - 0x02: Advertiser PHY is LE 2M
 * - 0x03: Advertiser PHY is LE Coded
 */
  uint8_t Advertiser_PHY;
/**
 * Periodic advertising interval. Time = N * 1.25 ms; Time Range: 7.5ms to
 * 81.91875 s.
 * Values:
 * - 0x0006 (7.50 ms)  ... 0xFFFF (NaN)
 */
  uint16_t Periodic_Advertising_Interval;
/**
 * Advertiser Clock Accuracy
 * Values:
 * - 0x00: 500 ppm
 * - 0x01: 250 ppm
 * - 0x02: 150 ppm
 * - 0x03: 100 ppm
 * - 0x04: 75 ppm
 * - 0x05: 60 ppm
 * - 0x06: 30 ppm
 * - 0x07: 20 ppm
 */
  uint8_t Advertiser_Clock_Accuracy;
/**
 * Number of subevents.
 * Values:
 * - 0x00 ... 0x80
 */
  uint8_t Num_Subevents;
/**
 * Subevent interval. Time = N x 1.25 ms.
 * Values:
 * - 0x00 (NaN) : No subevents
 * - 0x06 (7.50 ms)  ... 0xFF (318.75 ms)
 */
  uint8_t Subevent_Interval;
/**
 * Response slot delay. Range: 0x01 to 0xFE. Time = N x 1.25 ms
 * Values:
 * - 0x00 (NaN) : No response slots
 * - 0x01 (1.25 ms)  ... 0xFE (317.50 ms)
 */
  uint8_t Response_Slot_Delay;
/**
 * Response slot spacing Range: 0x02 to 0xFF Time = N x 0.125 ms
 * Values:
 * - 0x00 (0.000 ms) : No response slots
 * - 0x02 (0.250 ms)  ... 0xFF (31.875 ms)
 */
  uint8_t Response_Slot_Spacing;
} hci_le_periodic_advertising_sync_transfer_received_v2_event_rp0;

/**
 * The HCI_LE_Periodic_Advertising_Subevent_Data_Request event is used to allow
 * the Controller to indicate that it is ready to transmit one or more subevents
 * and is requesting the advertising data for these subevents. The
 * Subevent_Data_Count parameter shall be less than or equal to the number of
 * subevents. The Subevent_Start parameter is the first subevent being requested
 * and the Subevent_Data_Count parameter determines the subsequent subevents
 * being requested. The subevent numbers wrap from one less than the number of
 * subevents to zero. This event should be sent from the Controller when it has
 * no data for upcoming subevents. The Controller should request data for as
 * many subevents as it has memory to accept to minimize the number of events
 * generated by the Controller.
 */
typedef PACKED(struct) hci_le_periodic_advertising_subevent_data_request_event_rp0_s {
/**
 * Used to identify a periodic advertising train.
 */
  uint8_t Advertising_Handle;
/**
 * The first subevent that data is requested for.
 * Values:
 * - 0x00 ... 0x7F
 */
  uint8_t Subevent_Start;
/**
 * The number of subevents that data is requested for.
 * Values:
 * - 0x01 ... 0x80
 */
  uint8_t Subevent_Data_Count;
} hci_le_periodic_advertising_subevent_data_request_event_rp0;

/**
 * The HCI_LE_Periodic_Advertising_Response_Report event indicates that one or
 * more Bluetooth devices have responded to a periodic advertising subevent
 * during a PAwR train. The Controller may queue these advertising reports and
 * send information from multiple devices in one HCI_LE_Periodic_Advertising_-
 * Response_Report event. The Controller may fail to transmit the
 * synchronization packet required to enable the response packets to be sent. If
 * this happens, the Controller can report this to the Host using the Tx_Status
 * parameter. The Controller may split the data from a single response into
 * several reports. If so, each report except the last shall have a Data_Status
 * of "incomplete, more data to come", while the last shall have the value
 * "complete". No further reports shall be sent for a given periodic
 * advertisement after one with a Data_Status other than "incomplete, more data
 * to come".
 */
typedef PACKED(struct) hci_le_periodic_advertising_response_report_event_rp0_s {
/**
 * Used to identify a periodic advertising train.
 */
  uint8_t Advertising_Handle;
/**
 * The subevent number.
 */
  uint8_t Subevent;
/**
 * If AUX_SYNC_SUBEVENT_IND was transmitted or not.
 */
  uint8_t Tx_Status;
/**
 * Number of responses in event.
 * Values:
 * - 0x00 ... 0x19
 */
  uint8_t Num_Responses;
/**
 * See @ref packed_Periodic_Advertising_Response_t
 */
  packed_Periodic_Advertising_Response_t Periodic_Advertising_Response; /* N elements of variable size */
} hci_le_periodic_advertising_response_report_event_rp0;

/**
 * The HCI_LE_Enhanced_Connection_Complete event indicates to both of the Hosts
 * forming the connection that a new connection has been created. Upon the
 * creation of the connection a Connection_Handle shall be assigned by the
 * Controller, and passed to the Host in this event. If the connection creation
 * fails, this event shall be provided to the Host that had issued the
 * HCI_LE_Create_- Connection or HCI_LE_Extended_Create_Connection command. If
 * this event is unmasked and the HCI_LE_Connection_Complete event is unmasked,
 * only the HCI_LE_Enhanced_Connection_Complete event is sent when a new
 * connection has been created. This event indicates to the Host that issued an
 * HCI_LE_Create_Connection or HCI_LE_Extended_Create_Connection command and
 * received an HCI_Command_Status event if the connection creation failed or was
 * successful. The Peer_Address, Peer_Resolvable_Private_Address, and Local_-
 * Resolvable_Private_Address shall always reflect the most recent packet sent
 * and received on air. The Central_Clock_Accuracy parameter is only valid for a
 * Peripheral. On a Central, this parameter shall be set to 0x00. If the
 * connection is established from periodic advertising with responses and Role
 * is 0x00, then the Advertising_Handle parameter shall be set according to the
 * periodic advertising train the connection was established from. If the
 * connection is established from periodic advertising with responses and Role
 * is 0x01, then the Sync_Handle parameter shall be set according to the
 * periodic advertising train the connection was established from. In all other
 * circumstances, Advertising_Handle and Sync_Handle shall be set to No
 * Advertising_Handle and No Sync_Handle and shall be ignored by the Host.
 */
typedef PACKED(struct) hci_le_enhanced_connection_complete_v2_event_rp0_s {
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
/**
 * Connection handle to be used to identify the connection with the peer device.
 * Values:
 * - 0x0000 ... 0x0EFF
 */
  uint16_t Connection_Handle;
/**
 * Role of the local device in the connection.
 * Values:
 * - 0x00: Central
 * - 0x01: Peripheral
 */
  uint8_t Role;
/**
 * 0x00 Public Device Address 0x01 Random Device Address 0x02 Public Identity
 * Address (Corresponds to Resolved Private Address) 0x03 Random (Static)
 * Identity Address (Corresponds to Resolved Private Address)
 * Values:
 * - 0x00: Public Device Address
 * - 0x01: Random Device Address
 * - 0x02: Public Identity Address
 * - 0x03: Random (Static) Identity Address
 */
  uint8_t Peer_Address_Type;
/**
 * Public Device Address, Random Device Address, Public Identity Address or
 * Random (static) Identity Address of the device to be connected.
 */
  uint8_t Peer_Address[6];
/**
 * Resolvable Private Address being used by the local device for this
 * connection. This is only valid when the Own_Address_Type is set to 0x02 or
 * 0x03. For other Own_Address_Type values, the Controller shall return all
 * zeros.
 */
  uint8_t Local_Resolvable_Private_Address[6];
/**
 * Resolvable Private Address being used by the peer device for this connection.
 * This is only valid for Peer_Address_Type 0x02 and 0x03. For other
 * Peer_Address_Type values, the Controller shall return all zeros.
 */
  uint8_t Peer_Resolvable_Private_Address[6];
/**
 * Connection interval used on this connection. Time = N * 1.25 msec
 * Values:
 * - 0x0006 (7.50 ms)  ... 0x0C80 (4000.00 ms)
 */
  uint16_t Connection_Interval;
/**
 * Maximum Peripheral latency for the connection in number of connection events.
 * Values:
 * - 0x0000 ... 0x01F3
 */
  uint16_t Peripheral_Latency;
/**
 * Supervision timeout for the LE Link. It shall be a multiple of 10 ms and
 * larger than (1 + connPeripheralLatency) * connInterval * 2. Time = N * 10
 * msec.
 * Values:
 * - 0x000A (100 ms)  ... 0x0C80 (32000 ms)
 */
  uint16_t Supervision_Timeout;
/**
 * Central clock accuracy. Only valid for a Peripheral.
 * Values:
 * - 0x00: 500 ppm
 * - 0x01: 250 ppm
 * - 0x02: 150 ppm
 * - 0x03: 100 ppm
 * - 0x04: 75 ppm
 * - 0x05: 50 ppm
 * - 0x06: 30 ppm
 * - 0x07: 20 ppm
 */
  uint8_t Central_Clock_Accuracy;
/**
 * Used to identify an advertising set.
 */
  uint8_t Advertising_Handle;
/**
 * Sync_Handle identifying the periodic advertising train.
 * Values:
 * - 0x0000 ... 0x0EFF
 * - 0xFFFF: No Sync_Handle
 */
  uint16_t Sync_Handle;
} hci_le_enhanced_connection_complete_v2_event_rp0;

/**
  * @}
  */

/**
  * @}
  */

/**
  * @}
  */

/**
 *@addtogroup HAL_LL HAL/LL
 *@{
 */

/** @defgroup ACI_HAL_evt_code ACI HAL proprietary event codes
  * ACI HAL event codes found in ecode field of aci_blecore_event struct.
  * @{
  */

#define ACI_HAL_END_OF_RADIO_ACTIVITY_VSEVT_CODE                               0x0004
#define ACI_HAL_FW_ERROR_VSEVT_CODE                                            0x0006
#define ACI_HAL_ADV_SCAN_RESP_DATA_UPDATE_VSEVT_CODE                           0x0010
#define ACI_HAL_PAWR_DATA_FREE_VSEVT_CODE                                      0x0011

/**
  * @}
  */

/**
  * @}
  */

/**
 *@addtogroup GAP GAP
 *@brief Generic Access Profile
 *@{
 */

/** @defgroup ACI_GAP_evt_code ACI GAP proprietary event codes
  * ACI GAP event codes found in ecode field of aci_blecore_event struct.
  * @{
  */

#define ACI_GAP_LIMITED_DISCOVERABLE_VSEVT_CODE                                0x0400
#define ACI_GAP_PAIRING_COMPLETE_VSEVT_CODE                                    0x0401
#define ACI_GAP_PASSKEY_REQ_VSEVT_CODE                                         0x0402
#define ACI_GAP_PROC_COMPLETE_VSEVT_CODE                                       0x0407
#define ACI_GAP_ADDR_NOT_RESOLVED_VSEVT_CODE                                   0x0408
#define ACI_GAP_NUMERIC_COMPARISON_VALUE_VSEVT_CODE                            0x0409
#define ACI_GAP_KEYPRESS_NOTIFICATION_VSEVT_CODE                               0x040A
#define ACI_GAP_PAIRING_VSEVT_CODE                                             0x040B

/**
  * @}
  */

/**
  * @}
  */

/**
 *@addtogroup L2CAP L2CAP
 *@{
 */

/** @defgroup ACI_L2CAP_evt_code ACI L2CAP proprietary event codes
  * ACI L2CAP event codes found in ecode field of aci_blecore_event struct.
  * @{
  */

#define ACI_L2CAP_CONNECTION_UPDATE_RESP_VSEVT_CODE                            0x0800
#define ACI_L2CAP_PROC_TIMEOUT_VSEVT_CODE                                      0x0801
#define ACI_L2CAP_CONNECTION_UPDATE_REQ_VSEVT_CODE                             0x0802
#define ACI_L2CAP_COS_DISCONNECTION_COMPLETE_VSEVT_CODE                        0x0804
#define ACI_L2CAP_COS_FLOW_CONTROL_CREDIT_VSEVT_CODE                           0x0805
#define ACI_L2CAP_COS_SDU_DATA_TX_VSEVT_CODE                                   0x0806
#define ACI_L2CAP_COS_RECONFIGURATION_VSEVT_CODE                               0x0809
#define ACI_L2CAP_COMMAND_REJECT_VSEVT_CODE                                    0x080A
#define ACI_L2CAP_COS_SDU_DATA_RX_VSEVT_CODE                                   0x080D
#define ACI_L2CAP_COS_CONNECTION_REQ_VSEVT_CODE                                0x080E
#define ACI_L2CAP_COS_CONNECTION_RESP_VSEVT_CODE                               0x080F

/**
  * @}
  */

/**
  * @}
  */

/**
 *@addtogroup GATT GATT
 *@brief Generic Attribute Profile.
 *@{
 */

/** @defgroup ACI_GATT_evt_code ACI GATT proprietary event codes
  * ACI GATT event codes found in ecode field of aci_blecore_event struct.
  * @{
  */

#define ACI_GATT_SRV_ATTRIBUTE_MODIFIED_VSEVT_CODE                             0x0C01
#define ACI_GATT_PROC_TIMEOUT_VSEVT_CODE                                       0x0C02
#define ACI_ATT_EXCHANGE_MTU_RESP_VSEVT_CODE                                   0x0C03
#define ACI_ATT_CLT_FIND_INFO_RESP_VSEVT_CODE                                  0x0C04
#define ACI_ATT_CLT_FIND_BY_TYPE_VALUE_RESP_VSEVT_CODE                         0x0C05
#define ACI_ATT_CLT_READ_BY_TYPE_RESP_VSEVT_CODE                               0x0C06
#define ACI_ATT_CLT_READ_RESP_VSEVT_CODE                                       0x0C07
#define ACI_ATT_CLT_READ_BLOB_RESP_VSEVT_CODE                                  0x0C08
#define ACI_ATT_CLT_READ_MULTIPLE_RESP_VSEVT_CODE                              0x0C09
#define ACI_ATT_CLT_READ_BY_GROUP_TYPE_RESP_VSEVT_CODE                         0x0C0A
#define ACI_ATT_CLT_PREPARE_WRITE_RESP_VSEVT_CODE                              0x0C0C
#define ACI_ATT_CLT_EXEC_WRITE_RESP_VSEVT_CODE                                 0x0C0D
#define ACI_GATT_CLT_INDICATION_VSEVT_CODE                                     0x0C0E
#define ACI_GATT_CLT_NOTIFICATION_VSEVT_CODE                                   0x0C0F
#define ACI_GATT_CLT_PROC_COMPLETE_VSEVT_CODE                                  0x0C10
#define ACI_GATT_CLT_ERROR_RESP_VSEVT_CODE                                     0x0C11
#define ACI_GATT_CLT_DISC_READ_CHAR_BY_UUID_RESP_VSEVT_CODE                    0x0C12
#define ACI_GATT_TX_POOL_AVAILABLE_VSEVT_CODE                                  0x0C16
#define ACI_GATT_SRV_CONFIRMATION_VSEVT_CODE                                   0x0C17
#define ACI_GATT_SRV_READ_VSEVT_CODE                                           0x0C19
#define ACI_GATT_SRV_WRITE_VSEVT_CODE                                          0x0C1A
#define ACI_ATT_SRV_PREPARE_WRITE_REQ_VSEVT_CODE                               0x0C1B
#define ACI_ATT_SRV_EXEC_WRITE_REQ_VSEVT_CODE                                  0x0C1C
#define ACI_ATT_CLT_READ_MULTIPLE_VAR_LEN_RESP_VSEVT_CODE                      0x0C1E

/**
  * @}
  */

/**
  * @}
  */

/**
 *@addtogroup HAL_LL HAL/LL
 *@{
 */

/** @defgroup ACI_hal_evt_structs ACI HAL event structures
  * Types to be used to cast data field of hci_event_pckt type or
  * hci_event_ext_pckt type.
  * @{
  */

/**
 * This event is generated when the device completes a radio activity and
 * provide information when a new radio activity will be performed. Information
 * provided includes type of radio activity and absolute time in system ticks
 * when a new radio activity is schedule, if any. Application can use this
 * information to schedule user activities synchronous to selected radio
 * activities. A command @ref aci_hal_set_radio_activity_mask is provided to
 * enable radio activity events of user interests, by default no events are
 * enabled. User should take into account that enabling radio events in
 * application with intense radio activity could lead to a fairly high rate of
 * events generated. Application use cases includes synchronizing notification
 * with connection interval, switching  antenna at the end of advertising or
 * performing flash erase operation while radio is idle.
 */
typedef PACKED(struct) aci_hal_end_of_radio_activity_event_rp0_s {
/**
 * Completed radio events
 * Values:
 * - 0x00: Idle
 * - 0x01: Advertising
 * - 0x02: Connection event peripheral
 * - 0x03: Scanning
 * - 0x04: Connection request
 * - 0x05: Connection event central
 * - 0x06: TX test mode
 * - 0x07: RX test mode
 */
  uint8_t Last_State;
/**
 * Incoming radio events
 * Values:
 * - 0x00: Idle
 * - 0x01: Advertising
 * - 0x02: Connection event peripheral
 * - 0x03: Scanning
 * - 0x04: Connection request
 * - 0x05: Connection event central
 * - 0x06: TX test mode
 * - 0x07: RX test mode
 */
  uint8_t Next_State;
/**
 * 32bit absolute current time expressed in internal time units.
 */
  uint32_t Next_State_SysTime;
} aci_hal_end_of_radio_activity_event_rp0;

/**
 * This event is generated to report firmware error information.
 */
typedef PACKED(struct) aci_hal_fw_error_event_rp0_s {
/**
 * Code identifying the type of error that has occurred in Bluetooth stack.
 * 0x01: L2CAP layer failed recombining a PDU; 0x02: GATT layer received an
 * unexpteced response (protocol violation); 0x03: GATT layer received an
 * unexpteced request (protocol violation); 0x04: No space to store info GATT
 * database info in NVM (database clean-up  needed or bonding entries to be
 * removed); 0x05: No space to store bonding info in NVM  (database clean-up
 * needed or bonding entries to be removed); 0x06: Link Layer scheduler failed
 * to reschedule slots for too many times (a system reset is recommended; 0x07:
 * Out of memory resources for isochronous channels; 0x08: Error in programming
 * timer for CTE reception functionality.
 * Values:
 * - 0x01: HAL_FW_L2CAP_RECOMBINATION_ERROR
 * - 0x02: HAL_FW_GATT_UNEXPECTED_RESPONSE_ERROR
 * - 0x03: HAL_FW_GATT_SEQUENTIAL_PROTOCOL_ERROR
 * - 0x04: HAL_FW_BONDING_DB_FULL_GATTSERVICE_ERROR
 * - 0x05: HAL_FW_BONDING_DB_FULL_PAIRING_ERROR
 * - 0x06: HAL_FW_SCHEDULER_OVERRUN_ERROR
 * - 0x07: HAL_FW_MEMBUF_NOT_AVAILABLE
 * - 0x08: HAL_FW_CTE_TIMER_PROGRAM_ERROR
 */
  uint8_t FW_Error_Type;
/**
 * Length of Data in octets
 */
  uint8_t Data_Length;
/**
 * The error event info. If FW_Error_Type is 0x01, 0x02 or 0x03, this parameter
 * contains the connection handle where the abnormal condition has occurred.
 */
  uint8_t Data[(HCI_MAX_PAYLOAD_SIZE - 2)/sizeof(uint8_t)];
} aci_hal_fw_error_event_rp0;

/**
 * This event is raised when the advertising or scan response data pointer
 * provided by application becomes active or inactive.
 */
typedef PACKED(struct) aci_hal_adv_scan_resp_data_update_event_rp0_s {
/**
 *
 */
  void * Old_Pointer;
/**
 *
 */
  void * New_Pointer;
} aci_hal_adv_scan_resp_data_update_event_rp0;

/**
 * This event is raised when the PAwR subevent data or the PAwR response data
 * pointer provided by application is no more used by the stack and the
 * associated memory can be freed.
 */
typedef PACKED(struct) aci_hal_pawr_data_free_event_rp0_s {
/**
 * Pointer to the data that can be freed.
 */
  void * Buffer;
/**
 * Type of data pointed by the buffer.
 * Values:
 * - 0x00: HAL_PAWR_DATA_TYPE_SUBEVENT
 * - 0x01: HAL_PAWR_DATA_TYPE_RESPONSE
 */
  uint8_t Type;
} aci_hal_pawr_data_free_event_rp0;

/**
  * @}
  */

/**
  * @}
  */

/**
 *@addtogroup GAP GAP
 *@brief Generic Access Profile
 *@{
 */

/** @defgroup ACI_gap_evt_structs ACI GAP event structures
  * Types to be used to cast data field of hci_event_pckt type or
  * hci_event_ext_pckt type.
  * @{
  */

/**
 * This event is generated when the pairing process has completed successfully
 * or a pairing procedure timeout has occurred or the pairing has failed. This
 * is to notify the application that we have paired with a remote device so that
 * it can take further actions or to notify that a timeout has occurred so that
 * the upper layer can decide to disconnect the link.
 */
typedef PACKED(struct) aci_gap_pairing_complete_event_rp0_s {
/**
 * Connection handle on which the pairing procedure completed
 */
  uint16_t Connection_Handle;
/**
 * Pairing status. If 0x02, see Reason code.
 * Values:
 * - 0x00: Success
 * - 0x01: Timeout
 * - 0x02: Pairing Failed
 * - 0x03: Encryption failed, LTK missing on local device
 * - 0x04: Encryption failed, LTK missing on peer device
 * - 0x05: Encryption not supported by remote device
 */
  uint8_t Status;
/**
 * Pairing reason error code
 * Values:
 * - 0x00
 * - 0x01: SM_PASSKEY_ENTRY_FAILED
 * - 0x02: SM_OOB_NOT_AVAILABLE
 * - 0x03: SM_AUTHENTICATION_REQUIREMENTS
 * - 0x04: SM_CONFIRM_VALUE_FAILED
 * - 0x05: SM_PAIRING_NOT_SUPPORTED
 * - 0x06: SM_ENCRYPTION_KEY_SIZE
 * - 0x07: SM_CMD_NOT_SUPPORTED
 * - 0x08: SM_UNSPECIFIED_REASON
 * - 0x09: SM_REPEATED_ATTEMPTS
 * - 0x0A: SM_INVALID_PARAMETERS
 * - 0x0B: SMP_DHKEY_CHECK_FAILED
 * - 0x0C: SMP_NUMCOMPARISON_FAILED
 * - 0x0D: SM_BR_EDR_PAIRING_IN_PROGRESS
 * - 0x0E: SM_CROSS_TRANSPORT_KEY_NOT_ALLOWED
 * - 0x0F: SM_KEY_REJECTED
 */
  uint8_t Reason;
} aci_gap_pairing_complete_event_rp0;

/**
 * This event is generated by the Security manager to the application when a
 * passkey is required for pairing. When this event is received, the application
 * has to respond with the @ref aci_gap_passkey_resp command.
 */
typedef PACKED(struct) aci_gap_passkey_req_event_rp0_s {
/**
 * Connection handle for which the passkey has been requested.
 */
  uint16_t Connection_Handle;
/**
 * This parameter informs the application if the passkey needs to be displayed
 * or requested for input on the local device.
 * Values:
 * - 0x00: PASSKEY_DISPLAY
 * - 0x01: PASSKEY_INPUT
 */
  uint8_t Display_Input;
} aci_gap_passkey_req_event_rp0;

/**
 * This event is sent by the GAP to the upper layers when a procedure previously
 * started has been terminated by the upper layer or has completed for any other
 * reason
 */
typedef PACKED(struct) aci_gap_proc_complete_event_rp0_s {
/**
 * Code identifying the procedure.
 * Values:
 * - 0x00: GAP_LIMITED_DISCOVERY_PROC
 * - 0x01: GAP_GENERAL_DISCOVERY_PROC
 * - 0x02: GAP_AUTO_CONNECTION_ESTABLISHMENT_PROC
 * - 0x03: GAP_GENERAL_CONNECTION_ESTABLISHMENT_PROC
 * - 0x04: GAP_SELECTIVE_CONNECTION_ESTABLISHMENT_PROC
 * - 0x05: GAP_OBSERVATION_PROC
 * - 0x06: GAP_DIRECT_CONNECTION_ESTABLISHMENT_PROC
 * - 0x07: GAP_NAME_DISCOVERY_PROC
 */
  uint8_t Procedure_Code;
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Status;
/**
 * Length of Data in octets
 */
  uint8_t Data_Length;
/**
 * Procedure Specific Data: - For Name Discovery Procedure: the name of the peer
 * device if the procedure completed successfully.
 */
  uint8_t Data[(HCI_MAX_PAYLOAD_SIZE - 3)/sizeof(uint8_t)];
} aci_gap_proc_complete_event_rp0;

/**
 * This event is sent only by a privacy enabled Peripheral. The event is sent to
 * the upper layers when the peripheral is unsuccessful in resolving the
 * resolvable address of the peer device after connecting to it.
 */
typedef PACKED(struct) aci_gap_addr_not_resolved_event_rp0_s {
/**
 * Connection handle for which the private address could not be resolved with
 * any of the stored IRK's.
 */
  uint16_t Connection_Handle;
} aci_gap_addr_not_resolved_event_rp0;

/**
 * This event is sent only during SC v.4.2 Pairing, when Numeric Comparison
 * Association model is selected, in order to show the Numeric Value generated,
 * and to ask for Confirmation to the User. When this event is received, the
 * application has to respond with the  @ref
 * aci_gap_numeric_comparison_value_confirm_yesno command
 */
typedef PACKED(struct) aci_gap_numeric_comparison_value_event_rp0_s {
/**
 * Connection handle related to the underlying Pairing
 */
  uint16_t Connection_Handle;
/**
 *
 */
  uint32_t Numeric_Value;
} aci_gap_numeric_comparison_value_event_rp0;

/**
 * This event is sent only during SC v.4.2 Pairing, when Keypress Notifications
 * are supported, in order to show the input type signalled by the peer device,
 * having Keyboard only I/O capabilities. When this event is received, no action
 * is required to the User.
 */
typedef PACKED(struct) aci_gap_keypress_notification_event_rp0_s {
/**
 * Connection handle related to the underlying Pairing
 */
  uint16_t Connection_Handle;
/**
 * Type of Keypress input notified/signaled by peer device
 * Values:
 * - 0x00: PASSKEY_ENTRY_STARTED
 * - 0x01: PASSKEY_DIGIT_ENTERED
 * - 0x02: PASSKEY_DIGIT_ERASED
 * - 0x03: PASSKEY_CLEARED
 * - 0x04: PASSKEY_ENTRY_COMPLETED
 */
  uint8_t Notification_Type;
} aci_gap_keypress_notification_event_rp0;

/**
 * This event may be generated when there is a request to start a pairing
 * process.  Application shall respond with aci_gap_pairing_resp command to
 * accept or reject the incoming pairing procedure notified through this event.
 * If the pairing is going to start with a non-bonded device, the Bonded
 * parameter is set to 0. Instead, if the pairing process is going to start with
 * an already bonded device, the event is raised with Bonded parameter set to 1.
 * This may happen either if the peer has lost the bond or if it is a malicious
 * device.   If aci_gap_set_security_requirements command was given with
 * Pairing_Response set to 1 (pairing confirmation only for bonded devices), the
 * event is raised only if pairing is going to be initiated with a bonded
 * device.
 */
typedef PACKED(struct) aci_gap_pairing_event_rp0_s {
/**
 *
 */
  uint16_t Connection_Handle;
/**
 * Indicates if the peer device is already bonded or not.
 * Values:
 * - 0x00: DEVICE_NOT_BONDED
 * - 0x01: DEVICE_BONDED
 */
  uint8_t Bonded;
} aci_gap_pairing_event_rp0;

/**
  * @}
  */

/**
  * @}
  */

/**
 *@addtogroup L2CAP L2CAP
 *@{
 */

/** @defgroup ACI_l2cap_evt_structs ACI L2CAP event structures
  * Types to be used to cast data field of hci_event_pckt type or
  * hci_event_ext_pckt type.
  * @{
  */

/**
 * This event is generated when the central responds to the connection update
 * request packet with a connection update response packet.
 */
typedef PACKED(struct) aci_l2cap_connection_update_resp_event_rp0_s {
/**
 * Connection handle referring to the COS Channel where the Disconnection has
 * been received.
 */
  uint16_t Connection_Handle;
/**
 *
 */
  uint16_t Result;
} aci_l2cap_connection_update_resp_event_rp0;

/**
 * This event is generated when the central does not respond to the connection
 * update request packet with a connection update response packet or a command
 * reject packet within 30 seconds.
 */
typedef PACKED(struct) aci_l2cap_proc_timeout_event_rp0_s {
/**
 * Handle of the connection related to this L2CAP procedure.
 */
  uint16_t Connection_Handle;
/**
 * Length of following data
 */
  uint8_t Data_Length;
/**
 *
 */
  uint8_t Data[(HCI_MAX_PAYLOAD_SIZE - 3)/sizeof(uint8_t)];
} aci_l2cap_proc_timeout_event_rp0;

/**
 * The event is given by the L2CAP layer when a connection update request is
 * received from the peripheral. The upper layer which receives this event has
 * to respond by sending a @ref aci_l2cap_connection_parameter_update_resp
 * command.
 */
typedef PACKED(struct) aci_l2cap_connection_update_req_event_rp0_s {
/**
 * Handle of the connection related to this L2CAP procedure.
 */
  uint16_t Connection_Handle;
/**
 * This is the identifier which associates the request to the response.
 */
  uint8_t Identifier;
/**
 * Length of the L2CAP connection update request.
 */
  uint16_t L2CAP_Length;
/**
 * Minimum value for the connection event interval. This shall be less than or
 * equal to Connection_Interval_Max. Time = N * 1.25 msec.
 * Values:
 * - 0x0006 (7.50 ms)  ... 0x0C80 (4000.00 ms)
 */
  uint16_t Connection_Interval_Min;
/**
 * Maximum value for the connection event interval. This shall be greater than
 * or equal to Connection_Interval_Min. Time = N * 1.25 msec.
 * Values:
 * - 0x0006 (7.50 ms)  ... 0x0C80 (4000.00 ms)
 */
  uint16_t Connection_Interval_Max;
/**
 * Maximum Peripheral latency for the connection in number of connection events.
 * Values:
 * - 0x0000 ... 0x01F3
 */
  uint16_t Max_Latency;
/**
 * Defines connection timeout parameter in the following manner: Timeout
 * Multiplier * 10ms.
 * Values:
 * - 10 (100 ms)  ... 3200 (32000 ms)
 */
  uint16_t Timeout_Multiplier;
} aci_l2cap_connection_update_req_event_rp0;

/**
 * Event raised when an L2CAP channel using LE Credit Based Flow Control mode is
 * terminated.
 */
typedef PACKED(struct) aci_l2cap_cos_disconnection_complete_event_rp0_s {
/**
 * Handle identifying the connection.
 */
  uint16_t Connection_Handle;
/**
 * The local channel endpoint that identifies the L2CAP channel.
 */
  uint16_t CID;
} aci_l2cap_cos_disconnection_complete_event_rp0;

/**
 * Event raised when an L2CAP_FLOW_CONTROL_CREDIT_IND is received from the peer,
 * which means that it is capable of receiving additional K-frames (for example
 * after it has processed one or more K-frames) in LE Credit Based Flow Control.
 */
typedef PACKED(struct) aci_l2cap_cos_flow_control_credit_event_rp0_s {
/**
 * Handle identifying the connection.
 */
  uint16_t Connection_Handle;
/**
 * The local channel endpoint that identifies the L2CAP channel.
 */
  uint16_t CID;
/**
 * The number of additional k-frames that the peer's L2CAP layer entity can
 * receive.
 */
  uint16_t TX_Credits;
/**
 * Remaining number of K-frames that local L2CAP layer entity can currently send
 * to the peer.
 * Values:
 * - 1 ... 65535
 */
  uint16_t TX_Credit_Balance;
} aci_l2cap_cos_flow_control_credit_event_rp0;

/**
 * Event raised when an SDU to be transmitted has been processed by the local
 * L2CAP layer entity.
 */
typedef PACKED(struct) aci_l2cap_cos_sdu_data_tx_event_rp0_s {
/**
 * Handle identifying the connection.
 */
  uint16_t Connection_Handle;
/**
 * The local channel endpoint that identifies the L2CAP channel.
 */
  uint16_t CID;
/**
 *
 */
  uint16_t SDU_Length;
/**
 * Remaining number of K-frames that local L2CAP layer entity can currently send
 * to the peer.
 */
  uint16_t TX_Credit_Balance;
} aci_l2cap_cos_sdu_data_tx_event_rp0;

/**
 * Event generated when receiving an L2CAP_CREDIT_BASED_RECONFIGURE_REQ or an
 * L2CAP_CREDIT_BASED_RECONFIGURE_RSP, to reconfigure one or more (up to 5)
 * L2CAP Enhanced Credit Based Flow Control channels.
 */
typedef PACKED(struct) aci_l2cap_cos_reconfiguration_event_rp0_s {
/**
 * Connection handle that identifies the connection.
 * Values:
 * - 0x0000 ... 0x0EFF
 */
  uint16_t Connection_Handle;
/**
 *
 * Values:
 * - 0x00: L2CAP_ECFC_RECONFIGURE_REQ
 * - 0x01: L2CAP_ECFC_RECONFIGURE_RESP
 */
  uint8_t Event_Type;
/**
 * Result of the connection request if Event_Type is L2CAP_ECFC_CONN_RESP. To be
 * ignored if Event_Type is L2CAP_ECFC_CONN_REQ.
 * Values:
 * - 0x0000: L2CAP_RECONFIG_SUCCESSFUL
 * - 0x0001: L2CAP_RECONFIG_FAIL_MTU_REDUCTION_NOT_ALLOWED
 * - 0x0002: L2CAP_RECONFIG_FAIL_MPS_REDUCTION_NOT_ALLOWED
 * - 0x0003: L2CAP_RECONFIG_FAIL_INVALID_CID
 * - 0x0004: L2CAP_RECONFIG_FAIL_UNACCEPTABLE_PARAMETERS
 */
  uint16_t Result;
/**
 * This is the identifier which associates the request to the response.
 */
  uint8_t Identifier;
/**
 * The maximum SDU size (in octets) that the remote L2CAP layer entity can
 * receive on this channel after successful reconfiguration.
 * Values:
 * - 64 ... 65535
 */
  uint16_t Peer_MTU;
/**
 * The maximum PDU payload size (in octets) that the remote L2CAP layer entity
 * can receive on this channel after successful reconfiguration.
 * Values:
 * - 64 ... 65535
 */
  uint16_t Peer_MPS;
/**
 * Number of Channels that are going to be created.
 * Values:
 * - 0x01 ... 0x05
 */
  uint8_t CID_Count;
/**
 * Array of up to 5 two-octet values that represent the local channel endpoints
 * identifying the EATT channels to be reconfigured.
 */
  uint16_t Local_CID[(HCI_MAX_PAYLOAD_SIZE - 11)/sizeof(uint16_t)];
} aci_l2cap_cos_reconfiguration_event_rp0;

/**
 * This event is generated when the central rejects a L2CAP request.
 */
typedef PACKED(struct) aci_l2cap_command_reject_event_rp0_s {
/**
 * Handle identifying the connection.
 */
  uint16_t Connection_Handle;
/**
 * This is the identifier which associates the request to the response.
 */
  uint8_t Identifier;
/**
 * Reason
 */
  uint16_t Reason;
/**
 * Length of following data
 */
  uint8_t Data_Length;
/**
 * Data field associated with Reason
 */
  uint8_t Data[(HCI_MAX_PAYLOAD_SIZE - 6)/sizeof(uint8_t)];
} aci_l2cap_command_reject_event_rp0;

/**
 * Event raised when an SDU has been received. Use aci_l2cap_extract_sdu_data()
 * to extract SDU from buffer.
 */
typedef PACKED(struct) aci_l2cap_cos_sdu_data_rx_event_rp0_s {
/**
 * Handle identifying the connection.
 */
  uint16_t Connection_Handle;
/**
 * The local channel endpoint that identifies the L2CAP channel.
 */
  uint16_t CID;
/**
 * Remaining number of K-frames that local L2CAP layer entity can currently
 * receive from the peer. If automatic management of credits is enabled, this
 * number will automatically change after the SDU is extracted.
 */
  uint16_t RX_Credit_Balance;
/**
 *
 */
  uint16_t SDU_Length;
} aci_l2cap_cos_sdu_data_rx_event_rp0;

/**
 * Event generated when a request is received from the peer to create one L2CAP
 * Credit Based Flow Control channel or one or more (up to 5) L2CAP Enhanced
 * Credit Based Flow Control channels.
 */
typedef PACKED(struct) aci_l2cap_cos_connection_req_event_rp0_s {
/**
 * Connection handle that identifies the connection.
 * Values:
 * - 0x0000 ... 0x0EFF
 */
  uint16_t Connection_Handle;
/**
 * Type of channel: LE Credit Based Flow Control Mode or Enhanced Credit Based
 * Flow Control Mode.
 * Values:
 * - 0x00: L2CAP_CHANNEL_TYPE_LE_CFC
 * - 0x01: L2CAP_CHANNEL_TYPE_ECFC
 */
  uint8_t Channel_Type;
/**
 * This is the identifier which associates the request to the response.
 */
  uint8_t Identifier;
/**
 * Simplified Protocol/Service Multiplexer
 * Values:
 * - 0x0001 ... 0x00FF
 */
  uint16_t SPSM;
/**
 * The maximum SDU size (in octets) that the remote L2CAP layer entity can
 * receive on this channel.
 * Values:
 * - 64 ... 65535
 */
  uint16_t Peer_MTU;
/**
 * The maximum PDU payload size (in octets) that the remote L2CAP layer entity
 * can receive on this channel.
 * Values:
 * - 64 ... 65535
 */
  uint16_t Peer_MPS;
/**
 * The number of K-frames that can be sent to the L2CAP layer entity of the peer
 * device as soon as the L2CAP channel is established.
 */
  uint16_t Initial_Credits;
/**
 *
 */
  uint8_t CID_Count;
} aci_l2cap_cos_connection_req_event_rp0;

/**
 * Event generated when a response is received from the peer to create one L2CAP
 * Credit Based Flow Control channel or one or more (up to 5) L2CAP Enhanced
 * Credit Based Flow Control channels.
 */
typedef PACKED(struct) aci_l2cap_cos_connection_resp_event_rp0_s {
/**
 * Connection handle that identifies the connection.
 * Values:
 * - 0x0000 ... 0x0EFF
 */
  uint16_t Connection_Handle;
/**
 * Type of channel: LE Credit Based Flow Control Mode or Enhanced Credit Based
 * Flow Control Mode.
 * Values:
 * - 0x00: L2CAP_CHANNEL_TYPE_LE_CFC
 * - 0x01: L2CAP_CHANNEL_TYPE_ECFC
 */
  uint8_t Channel_Type;
/**
 * The maximum SDU size (in octets) that the remote L2CAP layer entity can
 * receive on this channel.
 * Values:
 * - 64 ... 65535
 */
  uint16_t Peer_MTU;
/**
 * The maximum PDU payload size (in octets) that the remote L2CAP layer entity
 * can receive on this channel.
 * Values:
 * - 64 ... 65535
 */
  uint16_t Peer_MPS;
/**
 * The number of K-frames that can be sent to the L2CAP layer entity of the peer
 * device as soon as the L2CAP channel is established.
 */
  uint16_t Initial_Credits;
/**
 * Outcome of the connection request.
 * Values:
 * - 0x0000: L2CAP_CONN_SUCCESSFUL
 * - 0x0002: L2CAP_CONN_FAIL_SPSM_NOT_SUPPORTED
 * - 0x0004: L2CAP_CONN_FAIL_INSUFFICIENT_RESOURCES
 * - 0x0005: L2CAP_CONN_FAIL_INSUFFICIENT_AUTHENTICATION
 * - 0x0006: L2CAP_CONN_FAIL_INSUFFICIENT_AUTHORIZATION
 * - 0x0007: L2CAP_CONN_FAIL_KEY_SIZE_TOO_SHORT
 * - 0x0008: L2CAP_CONN_FAIL_INSUFFICIENT_ENCRYPTION
 * - 0x0009: L2CAP_CONN_FAIL_INVALID_SOURCE_CID
 * - 0x000A: L2CAP_CONN_FAIL_SOURCE_CID_ALREADY_ALLOCATED
 * - 0x000B: L2CAP_CONN_FAIL_UNACCEPTABLE_PARAMETERS
 * - 0x000C: L2CAP_CONN_FAIL_INVALID_PARAMETERS
 * - 0x000D: L2CAP_CONN_FAIL_NO_INFO
 * - 0x000E: L2CAP_CONN_FAIL_AUTHENTICATION_PENDING
 * - 0x000F: L2CAP_CONN_FAIL_AUTHORIZATION_PENDING
 */
  uint16_t Result;
/**
 * Number of channels to be created which are present in the L2CAP Credit Based
 * Connection Request. The effective number of channels that will be opened can
 * be less than this value (see Local_CID) .
 * Values:
 * - 0x01 ... 0x05
 */
  uint8_t CID_Count;
/**
 * Array of up to 5 two-octet values that represent the local channel endpoints.
 */
  uint16_t CID[(HCI_MAX_PAYLOAD_SIZE - 12)/sizeof(uint16_t)];
} aci_l2cap_cos_connection_resp_event_rp0;

/**
  * @}
  */

/**
  * @}
  */

/**
 *@addtogroup GATT GATT
 *@brief Generic Attribute Profile.
 *@{
 */

/** @defgroup ACI_gatt_evt_structs ACI GATT event structures
  * Types to be used to cast data field of hci_event_pckt type or
  * hci_event_ext_pckt type.
  * @{
  */

/**
 * This event is generated to the application by the GATT server when a client
 * modifies any attribute on the server, as consequence of one of the following
 * GATT procedures: - write without response - signed write without response -
 * write characteristic value - write long characteristic value - reliable
 * write.
 */
typedef PACKED(struct) aci_gatt_srv_attribute_modified_event_rp0_s {
/**
 * The connection handle which modified the attribute.
 */
  uint16_t Connection_Handle;
/**
 * If equal to 0x0004, the event is related to an unenhanced ATT bearer.
 * Otherwise, the value is the local endpoint identifying the enhanced ATT
 * bearer.
 */
  uint16_t CID;
/**
 * Handle of the attribute that was modified.
 */
  uint16_t Attr_Handle;
/**
 * Length of Attr_Data in octets
 */
  uint16_t Attr_Data_Length;
/**
 * A concatenation of Handle, Length and Values for each of the attributes being
 * notified.
 */
  uint8_t Attr_Data[(HCI_MAX_PAYLOAD_SIZE - 8)/sizeof(uint8_t)];
} aci_gatt_srv_attribute_modified_event_rp0;

/**
 * This event is generated by the client/server to the application on a GATT
 * timeout (30 seconds). This is a critical event that should not happen during
 * normal operating conditions. It is an indication of either a major disruption
 * in the communication link or a mistake in the application which does not
 * provide a reply to GATT procedures. After this event, the GATT channel is
 * closed and no more GATT communication can be performed. The applications is
 * expected to issue an @ref aci_gap_terminate to disconnect from the peer
 * device.
 */
typedef PACKED(struct) aci_gatt_proc_timeout_event_rp0_s {
/**
 * Connection handle on which the GATT procedure has timed out
 */
  uint16_t Connection_Handle;
/**
 * If equal to 0x0004, the event is related to an unenhanced ATT bearer.
 * Otherwise, the value is the local endpoint identifying the enhanced ATT
 * bearer.
 */
  uint16_t CID;
} aci_gatt_proc_timeout_event_rp0;

/**
 * This event is generated in response to an Exchange MTU request (local or from
 * the peer), which can happen only on an unenhaced ATT bearer. See
 * aci_gatt_clt_exchange_config().
 */
typedef PACKED(struct) aci_att_exchange_mtu_resp_event_rp0_s {
/**
 * Connection handle related to the response
 */
  uint16_t Connection_Handle;
/**
 * ATT_MTU value agreed between server and client. This is the minimum of the
 * Client Rx MTU and the Server Rx MTU.
 */
  uint16_t MTU;
} aci_att_exchange_mtu_resp_event_rp0;

/**
 * This event is generated in response to a Find Information Request during a
 * discovery procedure for all the characteristic descriptors. See
 * aci_gatt_clt_disc_all_char_desc() and Find Information Response in Bluetooth
 * Core spec.
 */
typedef PACKED(struct) aci_att_clt_find_info_resp_event_rp0_s {
/**
 * Connection handle related to the response
 */
  uint16_t Connection_Handle;
/**
 * If equal to 0x0004, the event is related to an unenhanced ATT bearer.
 * Otherwise, the value is the local endpoint identifying the enhanced ATT
 * bearer.
 */
  uint16_t CID;
/**
 * Format of the hanndle-uuid pairs
 */
  uint8_t Format;
/**
 * Length of Handle_UUID_Pair in octets
 */
  uint16_t Event_Data_Length;
/**
 * A sequence of handle-uuid pairs. if format=1, each pair is:[2 octets for
 * handle, 2 octets for UUIDs], if format=2, each pair is:[2 octets for handle,
 * 16 octets for UUIDs]
 */
  uint8_t Handle_UUID_Pair[(HCI_MAX_PAYLOAD_SIZE - 7)/sizeof(uint8_t)];
} aci_att_clt_find_info_resp_event_rp0;

/**
 * This event is generated during a "discover service by UUID" procedure. See
 * aci_gatt_clt_disc_primary_service_by_uuid().
 */
typedef PACKED(struct) aci_att_clt_find_by_type_value_resp_event_rp0_s {
/**
 * Connection handle related to the response
 */
  uint16_t Connection_Handle;
/**
 * If equal to 0x0004, the event is related to an unenhanced ATT bearer.
 * Otherwise, the value is the local endpoint identifying the enhanced ATT
 * bearer.
 */
  uint16_t CID;
/**
 * Number of attribute, group handle pairs
 */
  uint8_t Num_of_Handle_Pair;
/**
 * See @ref packed_Attribute_Group_Handle_Pair_t
 */
  packed_Attribute_Group_Handle_Pair_t Attribute_Group_Handle_Pair[(HCI_MAX_PAYLOAD_SIZE - 5)/sizeof(packed_Attribute_Group_Handle_Pair_t)];
} aci_att_clt_find_by_type_value_resp_event_rp0;

/**
 * This event is generated in response to a ATT_READ_BY_TYPE_REQ, during a "find
 * included service" procedure or a "discover all characteristics" procedure.
 * See aci_gatt_clt_find_included_services() and
 * aci_gatt_clt_disc_all_char_of_service().
 */
typedef PACKED(struct) aci_att_clt_read_by_type_resp_event_rp0_s {
/**
 * Connection handle related to the response
 */
  uint16_t Connection_Handle;
/**
 * If equal to 0x0004, the event is related to an unenhanced ATT bearer.
 * Otherwise, the value is the local endpoint identifying the enhanced ATT
 * bearer.
 */
  uint16_t CID;
/**
 * The size of each attribute handle-value pair
 */
  uint8_t Handle_Value_Pair_Length;
/**
 * Length of Handle_Value_Pair_Data in octets
 */
  uint16_t Data_Length;
/**
 * Attribute Data List as defined in Bluetooth Core v4.1 spec. A sequence of
 * handle-value pairs: [2 octets for Attribute Handle, (Handle_Value_Pair_Length
 * - 2 octets) for Attribute Value]
 */
  uint8_t Handle_Value_Pair_Data[(HCI_MAX_PAYLOAD_SIZE - 7)/sizeof(uint8_t)];
} aci_att_clt_read_by_type_resp_event_rp0;

/**
 * This event is generated in response to a Read Request. See
 * aci_gatt_clt_read().
 */
typedef PACKED(struct) aci_att_clt_read_resp_event_rp0_s {
/**
 * Connection handle related to the response
 */
  uint16_t Connection_Handle;
/**
 * If equal to 0x0004, the event is related to an unenhanced ATT bearer.
 * Otherwise, the value is the local endpoint identifying the enhanced ATT
 * bearer.
 */
  uint16_t CID;
/**
 * Length of following data
 */
  uint16_t Event_Data_Length;
/**
 * The value of the attribute.
 */
  uint8_t Attribute_Value[(HCI_MAX_PAYLOAD_SIZE - 6)/sizeof(uint8_t)];
} aci_att_clt_read_resp_event_rp0;

/**
 * This event can be generated during a read long characteristic value
 * procedure. See aci_gatt_clt_read_long().
 */
typedef PACKED(struct) aci_att_clt_read_blob_resp_event_rp0_s {
/**
 * Connection handle related to the response
 */
  uint16_t Connection_Handle;
/**
 * If equal to 0x0004, the event is related to an unenhanced ATT bearer.
 * Otherwise, the value is the local endpoint identifying the enhanced ATT
 * bearer.
 */
  uint16_t CID;
/**
 * Length of following data
 */
  uint16_t Event_Data_Length;
/**
 * Part of the attribute value.
 */
  uint8_t Attribute_Value[(HCI_MAX_PAYLOAD_SIZE - 6)/sizeof(uint8_t)];
} aci_att_clt_read_blob_resp_event_rp0;

/**
 * This event is generated in response to a Read Multiple Request. See
 * aci_gatt_clt_read_multiple_char_value().
 */
typedef PACKED(struct) aci_att_clt_read_multiple_resp_event_rp0_s {
/**
 * Connection handle related to the response
 */
  uint16_t Connection_Handle;
/**
 * If equal to 0x0004, the event is related to an unenhanced ATT bearer.
 * Otherwise, the value is the local endpoint identifying the enhanced ATT
 * bearer.
 */
  uint16_t CID;
/**
 * Length of following data
 */
  uint16_t Event_Data_Length;
/**
 * A set of two or more values. A concatenation of attribute values for each of
 * the attribute handles in the request in the order that they were requested.
 */
  uint8_t Set_Of_Values[(HCI_MAX_PAYLOAD_SIZE - 6)/sizeof(uint8_t)];
} aci_att_clt_read_multiple_resp_event_rp0;

/**
 * This event is generated in response to a Read By Group Type Request, during a
 * "discover all primary services" procedure. See
 * aci_gatt_clt_disc_all_primary_services().
 */
typedef PACKED(struct) aci_att_clt_read_by_group_type_resp_event_rp0_s {
/**
 * Connection handle related to the response
 */
  uint16_t Connection_Handle;
/**
 * If equal to 0x0004, the event is related to an unenhanced ATT bearer.
 * Otherwise, the value is the local endpoint identifying the enhanced ATT
 * bearer.
 */
  uint16_t CID;
/**
 * The size of each attribute data
 */
  uint8_t Attribute_Data_Length;
/**
 * Length of Attribute_Data_List in octets
 */
  uint16_t Data_Length;
/**
 * Attribute Data List as defined in Bluetooth Core v4.1 spec. A sequence of
 * attribute handle, end group handle, attribute value tuples: [2 octets for
 * Attribute Handle, 2 octets End Group Handle, (Attribute_Data_Length - 4
 * octets) for Attribute Value]
 */
  uint8_t Attribute_Data_List[(HCI_MAX_PAYLOAD_SIZE - 7)/sizeof(uint8_t)];
} aci_att_clt_read_by_group_type_resp_event_rp0;

/**
 * This event is generated in response to an ATT_PREPARE_WRITE_REQ during a
 * write long characteristic value procedure. See aci_gatt_clt_write_long().
 */
typedef PACKED(struct) aci_att_clt_prepare_write_resp_event_rp0_s {
/**
 * Connection handle related to the response
 */
  uint16_t Connection_Handle;
/**
 * If equal to 0x0004, the event is related to an unenhanced ATT bearer.
 * Otherwise, the value is the local endpoint identifying the enhanced ATT
 * bearer.
 */
  uint16_t CID;
/**
 * The handle of the attribute to be written
 */
  uint16_t Attribute_Handle;
/**
 * The offset of the first octet to be written.
 */
  uint16_t Offset;
/**
 * Length of Part_Attribute_Value in octets
 */
  uint16_t Part_Attribute_Value_Length;
/**
 * The value of the attribute to be written
 */
  uint8_t Part_Attribute_Value[(HCI_MAX_PAYLOAD_SIZE - 10)/sizeof(uint8_t)];
} aci_att_clt_prepare_write_resp_event_rp0;

/**
 * This event is generated in response to an ATT Execute Write Request, during a
 * write long characteristic value procedure. See aci_gatt_clt_write_long().
 */
typedef PACKED(struct) aci_att_clt_exec_write_resp_event_rp0_s {
/**
 * Connection handle related to the response
 */
  uint16_t Connection_Handle;
/**
 * If equal to 0x0004, the event is related to an unenhanced ATT bearer.
 * Otherwise, the value is the local endpoint identifying the enhanced ATT
 * bearer.
 */
  uint16_t CID;
} aci_att_clt_exec_write_resp_event_rp0;

/**
 * This event is generated when an indication is received from the server.
 */
typedef PACKED(struct) aci_gatt_clt_indication_event_rp0_s {
/**
 * Connection handle related to the response
 */
  uint16_t Connection_Handle;
/**
 * If equal to 0x0004, the event is related to an unenhanced ATT bearer.
 * Otherwise, the value is the local endpoint identifying the enhanced ATT
 * bearer.
 */
  uint16_t CID;
/**
 * The handle of the attribute
 */
  uint16_t Attribute_Handle;
/**
 * Length of Attribute_Value in octets
 */
  uint16_t Attribute_Value_Length;
/**
 * The current value of the attribute
 */
  uint8_t Attribute_Value[(HCI_MAX_PAYLOAD_SIZE - 8)/sizeof(uint8_t)];
} aci_gatt_clt_indication_event_rp0;

/**
 * This event is generated when a notification is received from the server.
 */
typedef PACKED(struct) aci_gatt_clt_notification_event_rp0_s {
/**
 * Connection handle related to the response
 */
  uint16_t Connection_Handle;
/**
 * If equal to 0x0004, the event is related to an unenhanced ATT bearer.
 * Otherwise, the value is the local endpoint identifying the enhanced ATT
 * bearer.
 */
  uint16_t CID;
/**
 * The handle of the attribute
 */
  uint16_t Attribute_Handle;
/**
 * Length of Attribute_Value in octets
 */
  uint16_t Attribute_Value_Length;
/**
 * The current value of the attribute
 */
  uint8_t Attribute_Value[(HCI_MAX_PAYLOAD_SIZE - 8)/sizeof(uint8_t)];
} aci_gatt_clt_notification_event_rp0;

/**
 * This event is generated when a GATT client procedure completes either with
 * error or successfully.
 */
typedef PACKED(struct) aci_gatt_clt_proc_complete_event_rp0_s {
/**
 * Connection handle related to the response
 */
  uint16_t Connection_Handle;
/**
 * If equal to 0x0004, the event is related to an unenhanced ATT bearer.
 * Otherwise, the value is the local endpoint identifying the enhanced ATT
 * bearer.
 */
  uint16_t CID;
/**
 * For standard error codes see Bluetooth specification, Vol. 2, part D. For
 * proprietary error code refer to Error codes section.
 */
  uint8_t Error_Code;
} aci_gatt_clt_proc_complete_event_rp0;

/**
 * This event is generated when an Error Response is received from the server.
 * The error response can be given by the server at the end of one of the GATT
 * discovery procedures. This does not mean that the procedure ended with an
 * error, but this error event is part of the procedure itself.
 */
typedef PACKED(struct) aci_gatt_clt_error_resp_event_rp0_s {
/**
 * Connection handle related to the response
 */
  uint16_t Connection_Handle;
/**
 * If equal to 0x0004, the event is related to an unenhanced ATT bearer.
 * Otherwise, the value is the local endpoint identifying the enhanced ATT
 * bearer.
 */
  uint16_t CID;
/**
 * The request that generated this error response
 */
  uint8_t Req_Opcode;
/**
 * The attribute handle that generated this error response
 */
  uint16_t Attribute_Handle;
/**
 * The reason why the request has generated an error response (ATT error codes)
 * Values:
 * - 0x01: Invalid handle
 * - 0x02: Read not permitted
 * - 0x03: Write not permitted
 * - 0x04: Invalid PDU
 * - 0x05: Insufficient authentication
 * - 0x06: Request not supported
 * - 0x07: Invalid offset
 * - 0x08: Insufficient authorization
 * - 0x09: Prepare queue full
 * - 0x0A: Attribute not found
 * - 0x0B: Attribute not long
 * - 0x0C: Insufficient encryption key size
 * - 0x0D: Invalid attribute value length
 * - 0x0E: Unlikely error
 * - 0x0F: Insufficient encryption
 * - 0x10: Unsupported group type
 * - 0x11: Insufficient resources
 */
  uint8_t Error_Code;
} aci_gatt_clt_error_resp_event_rp0;

/**
 * This event can be generated during a "Discover Characteristics By UUID"
 * procedure or a "Read using Characteristic UUID" procedure. During a "Discover
 * Characteristics By UUID" procedure, Attribute_Value is a characteristic
 * declaration as defined in Bluetooth Core spec (vol.3, Part G, ch. 3.3.1),
 * i.e. it is composed by: Characteristic Properties (1 octet), Characteristic
 * Value Handle (2 octets) and Characteristic UUID (2 or 16 octets). During a
 * "Read using Characteristic UUID" procedure, Attribute_Value is the value of
 * the characteristic.
 */
typedef PACKED(struct) aci_gatt_clt_disc_read_char_by_uuid_resp_event_rp0_s {
/**
 * Connection handle related to the response
 */
  uint16_t Connection_Handle;
/**
 * If equal to 0x0004, the event is related to an unenhanced ATT bearer.
 * Otherwise, the value is the local endpoint identifying the enhanced ATT
 * bearer.
 */
  uint16_t CID;
/**
 * The handle of the attribute
 */
  uint16_t Attribute_Handle;
/**
 * Length of Attribute_Value in octets
 */
  uint8_t Attribute_Value_Length;
/**
 * The attribute value will be a characteristic declaration as defined in
 * Bluetooth Core spec (vol.3, Part G, ch. 3.3.1), when a "Discover
 * Characteristics By UUID" has been started. It will be the value of the
 * Characteristic if a "Read using Characteristic UUID" has been performed.
 */
  uint8_t Attribute_Value[(HCI_MAX_PAYLOAD_SIZE - 7)/sizeof(uint8_t)];
} aci_gatt_clt_disc_read_char_by_uuid_resp_event_rp0;

/**
 * Each time Bluetooth stack raises the error code
 * BLE_STATUS_INSUFFICIENT_RESOURCES, aci_gatt_tx_pool_available_event() is
 * generated as soon as the available buffer size is greater than maximum ATT
 * MTU.
 */
typedef PACKED(struct) aci_gatt_tx_pool_available_event_rp0_s {
/**
 * Connection handle related to the request
 */
  uint16_t Connection_Handle;
/**
 * Not used.
 */
  uint16_t Available_Buffers;
} aci_gatt_tx_pool_available_event_rp0;

/**
 * This event is generated when the client has sent the confirmation to a
 * previously sent indication.
 */
typedef PACKED(struct) aci_gatt_srv_confirmation_event_rp0_s {
/**
 * Connection handle related to the event.
 */
  uint16_t Connection_Handle;
/**
 * If equal to 0x0004, the event is related to an unenhanced ATT bearer.
 * Otherwise, the value is the local endpoint identifying the enhanced ATT
 * bearer.
 */
  uint16_t CID;
} aci_gatt_srv_confirmation_event_rp0;

/**
 * This event is generated when the BLE stack needs an attribute value to be
 * returned to the peer, as a result of a remote read operation (Read By Type
 * Request, Read Request, Read Blob Request, Read Multiple Request). After this
 * event is received, aci_gatt_srv_resp() must be used to send the response.
 * This event is not generated if the read is requested on a characteristic or a
 * descriptor which have an associated buffer handled by the stack (see
 * ble_gatt_chr_def_t and ble_gatt_descr_def_t).
 */
typedef PACKED(struct) aci_gatt_srv_read_event_rp0_s {
/**
 * Handle identifying the connection where the read operation has been received.
 */
  uint16_t Connection_Handle;
/**
 * If equal to 0x0004, the event is related to an unenhanced ATT bearer.
 * Otherwise, the value is the local endpoint identifying the enhanced ATT
 * bearer.
 */
  uint16_t CID;
/**
 * Handle of the attribute to read.
 */
  uint16_t Attribute_Handle;
/**
 * Offset from which the peer is requesting the attribute value.
 */
  uint16_t Data_Offset;
} aci_gatt_srv_read_event_rp0;

/**
 * This event is generated when the peer wants to write into a writable
 * characteristic value or descriptor using a write request or command (Write
 * Request, Write command, Signed Write command). If a response is needed,
 * application must respond with an aci_gatt_srv_resp().
 */
typedef PACKED(struct) aci_gatt_srv_write_event_rp0_s {
/**
 * Handle identifying the connection where the write operation has been
 * received.
 */
  uint16_t Connection_Handle;
/**
 * If equal to 0x0004, the event is related to an unenhanced ATT bearer.
 * Otherwise, the value is the local endpoint identifying the enhanced ATT
 * bearer.
 */
  uint16_t CID;
/**
 * If 1, application must call aci_gatt_srv_resp() to give a response to the
 * peer.
 */
  uint8_t Resp_Needed;
/**
 * Handle of the attribute to write.
 */
  uint16_t Attribute_Handle;
/**
 * Length of the data to write.
 */
  uint16_t Data_Length;
/**
 * Data to write.
 */
  uint8_t Data[(HCI_MAX_PAYLOAD_SIZE - 9)/sizeof(uint8_t)];
} aci_gatt_srv_write_event_rp0;

/**
 * This event is generated when a prepare write request is received. Application
 * should queue this request and execute or discard it only when a
 * aci_att_srv_exec_write_req_event is received.
 */
typedef PACKED(struct) aci_att_srv_prepare_write_req_event_rp0_s {
/**
 * Handle identifying the connection where the prepare write operation has been
 * received.
 */
  uint16_t Connection_Handle;
/**
 * If equal to 0x0004, the event is related to an unenhanced ATT bearer.
 * Otherwise, the value is the local endpoint identifying the enhanced ATT
 * bearer.
 */
  uint16_t CID;
/**
 * Handle of the attribute to write.
 */
  uint16_t Attribute_Handle;
/**
 * Offset from which data has to be written.
 */
  uint16_t Data_Offset;
/**
 * Length of the data to write.
 */
  uint16_t Data_Length;
/**
 * Data to write.
 */
  uint8_t Data[(HCI_MAX_PAYLOAD_SIZE - 10)/sizeof(uint8_t)];
} aci_att_srv_prepare_write_req_event_rp0;

/**
 * This event is generated when an execute write request is received from the
 * peer. This happens when the client wants to write a long attribute (i.e. an
 * attribute with a size greater than ATT_MTU -3) or more than one attribute in
 * a single operation. The aci_gatt_srv_resp command must be sent to give a
 * response to the peer.
 */
typedef PACKED(struct) aci_att_srv_exec_write_req_event_rp0_s {
/**
 * Handle identifying the connection where the execute write operation has been
 * received.
 */
  uint16_t Connection_Handle;
/**
 * If equal to 0x0004, the event is related to an unenhanced ATT bearer.
 * Otherwise, the value is the local endpoint identifying the enhanced ATT
 * bearer.
 */
  uint16_t CID;
/**
 * If 1, peer wants to execute all the queued writes. If 0, all queued writes
 * must be discarded.
 * Values:
 * - 0x00: FLUSH
 * - 0x01: EXECUTE
 */
  uint8_t Flags;
} aci_att_srv_exec_write_req_event_rp0;

/**
 * This event is generated in response to a Read Multiple Variable Request. See
 * aci_gatt_clt_read_multiple_var_len_char_value().
 */
typedef PACKED(struct) aci_att_clt_read_multiple_var_len_resp_event_rp0_s {
/**
 * Connection handle related to the response
 */
  uint16_t Connection_Handle;
/**
 * If equal to 0x0004, the event is related to an unenhanced ATT bearer.
 * Otherwise, the value is the local endpoint identifying the enhanced ATT
 * bearer.
 */
  uint16_t CID;
/**
 * Length of following data
 */
  uint16_t Event_Data_Length;
/**
 * A set of two or more values. A concatenation of attribute values for each of
 * the attribute handles in the request in the order that they were requested.
 */
  uint8_t Set_Of_Values[(HCI_MAX_PAYLOAD_SIZE - 6)/sizeof(uint8_t)];
} aci_att_clt_read_multiple_var_len_resp_event_rp0;

/**
  * @}
  */

/**
  * @}
  */

#endif /* _BLE_EVENTS_H_ */
