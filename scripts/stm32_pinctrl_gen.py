"""
Utility to autogenerate Zephyr DT pinctrl files for all STM32 microcontrollers.

Usage::

    python3 stm32_pinctrl_gen.py -p /path/to/STM32CubeMX -o /path/to/output_dir

Copyright (c) 2020 Teslabs Engineering S.L.

SPDX-License-Identifier: Apache-2.0
"""

import argparse
import glob
import logging
import os
import re
import shutil
import xml.etree.ElementTree as ET


logger = logging.getLogger(__name__)


NS = "{http://mcd.rou.st.com/modules.php?name=mcu}"
"""MCU XML namespace."""

PINCTRL_TEMPLATE = """
/*
 * NOTE: Autogenerated file using stm32_pinctrl_gen.py
 *
 * SPDX-License-Identifier: Apache-2.0
 */

#include <dt-bindings/pinctrl/stm32-pinctrl.h>

/ {{
\tsoc {{
\t\tpinctrl: pin-controller@{pinctrl_addr:08X} {{
{pinctrl_entries}
\t\t}};
\t}};
}};
"""
"""pinctrl file template."""

PINCTRL_GROUP_TEMPLATE = "\t\t\t/* {group} */\n"
"""pinctrl group template."""

PINCTRL_ENTRY_TEMPLATE = """\t\t\t{signal}_p{port}{pin}: {signal}_p{port}{pin} {{
\t\t\t\tpinmux = <STM32_PINMUX_Z(STM32_DT_PORT_{port}, {pin}, AF{af})>;
{drive}{bias}\t\t\t}};\n\n"""
"""pinctrl entry template."""

PINCTRL_DRIVE_TEMPLATE = "\t\t\t\tdrive-{drive};\n"
"""pinctrl drive template."""

PINCTRL_BIAS_TEMPLATE = "\t\t\t\tbias-{bias};\n"
"""pinctrl bias template."""

PINCTRL_SETTINGS = [
    {
        "name": "UART_CTS",
        "matches": [r"UART\d+_CTS", r"USART\d+_CTS", r"LPUART\d+_CTS"],
        "drive": "open-drain",
        "bias": "pull-up",
    },
    {
        "name": "UART_RTS",
        "matches": [r"UART\d+_RTS", r"USART\d+_RTS", r"LPUART\d+_RTS"],
        "drive": "open-drain",
        "bias": "pull-up",
    },
    {
        "name": "UART_TX",
        "matches": [r"UART\d+_TX", r"USART\d+_TX", r"LPUART\d+_TX"],
        "drive": "push-pull",
        "bias": "pull-up",
    },
    {
        "name": "UART_RX",
        "matches": [r"UART\d+_RX", r"USART\d+_RX", r"LPUART\d+_RX"],
        "bias": "disable",
    },
]
"""pinctrl settings for supported signals."""

PINCTRL_ADDR = {
    "stm32f0": 0x48000000,
    "stm32f1": 0x40010800,
    "stm32f2": 0x40020000,
    "stm32f3": 0x48000000,
    "stm32f4": 0x40020000,
    "stm32f7": 0x40020000,
    "stm32g0": 0x50000000,
    "stm32g4": 0x48000000,
    "stm32h7": 0x58020000,
    "stm32l0": 0x50000000,
    "stm32l4": 0x48000000,
    "stm32l5": 0x42020000,
    "stm32mp1": 0x50002000,
    "stm32wb": 0x48000000,
}
"""pinctrl peripheral address for each family."""


def get_gpio_ip_afs(cube_path):
    """Obtain all GPIO IP alternate functions.

    Example output::

        {
            "STM32L4P_gpio_v1_0": {
                "PA2": {
                    "EVENTOUT": 15,
                    "LPUART1_TX": 8,
                    ...
                },
                ...
            },
            ...
        }

    Args:
        cube_path: Path to CubeMX package.

    Returns:
        Dictionary of alternate functions.
    """

    ip_path = os.path.join(cube_path, "db", "mcu", "IP")
    if not os.path.exists(ip_path):
        raise FileNotFoundError(f"IP DB folder '{ip_path}' does not exist")

    results = dict()

    for gpio_file in glob.glob(os.path.join(ip_path, "GPIO-*_Modes.xml")):
        m = re.search(r"GPIO-(.*)_Modes.xml", gpio_file)
        gpio_ip = m.group(1)

        gpio_ip_entries = dict()
        results[gpio_ip] = gpio_ip_entries

        gpio_tree = ET.parse(gpio_file)
        gpio_root = gpio_tree.getroot()

        for pin in gpio_root.findall(NS + "GPIO_Pin"):
            pin_name = pin.get("Name")

            pin_entries = dict()
            gpio_ip_entries[pin_name] = pin_entries

            for signal in pin.findall(NS + "PinSignal"):
                signal_name = signal.get("Name")

                param = signal.find(NS + "SpecificParameter")
                if not param:
                    # NOTE: Only notify error if not F1 IP. F1 may use re-mapping
                    # which is not supported.
                    if "STM32F1" not in gpio_ip:
                        logger.error(
                            f"Missing signal {signal_name} parameters (ip: {gpio_ip})"
                        )
                    continue

                value = param.find(NS + "PossibleValue")
                if not param:
                    logger.error(f"Missing signal {signal_name} value (ip: {gpio_ip})")
                    continue

                m = re.search(r"^GPIO_AF(\d+)_[A-Z0-9]+", value.text)
                if not m:
                    # NOTE: Only notify error if not F1 IP. F1 may use re-mapping
                    # definitions which are not supported.
                    if "STM32F1" not in gpio_ip:
                        logger.error(
                            f"Unexpected AF format: {value.text} (ip: {gpio_ip})"
                        )
                    continue

                af_n = int(m.group(1))
                pin_entries[signal_name] = af_n

    return results


def get_mcu_signals(cube_path, gpio_ip_afs):
    """Obtain all MCU signals.

    Example output::

        {
            "STM32WB": [
                {
                    "name": "STM32WB30CEUx"
                    "pins: [
                        {
                            "name": "PA0",
                            "signals" : [
                                {
                                    "name": "ADC1_IN5",
                                    "af": 8
                                },
                                ...
                            ]
                        },
                        ...
                    ]
                },
                ...
            ]
        }

    Args:
        cube_path: Path to CubeMX.
        gpio_ip_afs: GPIO IP alternate functions.

    Returns:
        Dictionary with all MCU signals.
    """

    mcus_path = os.path.join(cube_path, "db", "mcu")
    if not os.path.exists(mcus_path):
        raise FileNotFoundError(f"MCU DB folder '{mcus_path}' does not exist")

    results = dict()

    for mcu_file in glob.glob(os.path.join(mcus_path, "STM32*.xml")):
        mcu_tree = ET.parse(mcu_file)
        mcu_root = mcu_tree.getroot()

        # obtain family, reference and GPIO IP
        family = mcu_root.get("Family")
        ref = mcu_root.get("RefName")

        gpio_ip_version = None
        for ip in mcu_root.findall(NS + "IP"):
            if ip.get("Name") == "GPIO":
                gpio_ip_version = ip.get("Version")
                break

        if not gpio_ip_version:
            logger.error(f"GPIO IP version not specified (mcu: {mcu_file})")
            continue

        if gpio_ip_version not in gpio_ip_afs:
            logger.error(f"GPIO IP version {gpio_ip_version} not available")
            continue

        gpio_ip = gpio_ip_afs[gpio_ip_version]

        # create reference entry on its family
        if family not in results:
            family_entries = list()
            results[family] = family_entries
        else:
            family_entries = results[family]

        pin_entries = list()
        family_entries.append({"name": ref, "pins": pin_entries})

        # process all pins
        for pin in mcu_root.findall(NS + "Pin"):
            if pin.get("Type") != "I/O":
                continue

            m = re.search(r"^P[A-Z]\d+", pin.get("Name"))
            if not m:
                continue

            pin_name = m.group(0)
            if pin_name not in gpio_ip:
                continue

            pin_afs = gpio_ip[pin_name]

            pin_signals = list()
            pin_entries.append({"name": pin_name, "signals": pin_signals})

            # process all pin signals
            for signal in pin.findall(NS + "Signal"):
                if signal.get("Name") == "GPIO":
                    continue

                signal_name = signal.get("Name")
                if signal_name not in pin_afs:
                    continue

                pin_af = pin_afs[signal_name]
                pin_signals.append({"name": signal_name, "af": pin_af})

    return results


def main(cube_path, output):
    """Entry point.

    Args:
        cube_path: CubeMX path.
        output: Output directory.
    """

    gpio_ip_afs = get_gpio_ip_afs(cube_path)
    mcu_signals = get_mcu_signals(cube_path, gpio_ip_afs)

    if os.path.exists(output):
        shutil.rmtree(output)

    os.makedirs(output)

    for family, refs in mcu_signals.items():
        # obtain family pinctrl address
        pinctrl_addr = PINCTRL_ADDR.get(family.lower())
        if not pinctrl_addr:
            continue

        # create directory for each family
        family_dir = os.path.join(output, family.lower()[5:])
        if not os.path.exists(family_dir):
            os.makedirs(family_dir)

        # process each reference
        for ref in refs:
            entries = dict()

            # process each pin in the current reference
            for pin in ref["pins"]:
                # obtain pin port (A, B, ...) and number (0, 1, ...)
                m = re.search(r"^P([A-Z])(\d+)$", pin["name"])
                if not m:
                    logger.error(f"Unexpected pin name format: {pin['name']}")
                    continue

                pin_port = m.group(1).lower()
                pin_number = int(m.group(2))

                # process each pin available signal (matched against settings table)
                for signal in pin["signals"]:
                    for setting in PINCTRL_SETTINGS:
                        for match in setting["matches"]:
                            m = re.search(match, signal["name"])
                            if not m:
                                continue

                            if setting["name"] not in entries:
                                entries[setting["name"]] = list()

                            if setting.get("drive"):
                                drive = PINCTRL_DRIVE_TEMPLATE.format(
                                    drive=setting.get("drive")
                                )
                            else:
                                drive = ""

                            if setting.get("bias"):
                                bias = PINCTRL_BIAS_TEMPLATE.format(
                                    bias=setting.get("bias")
                                )
                            else:
                                bias = ""

                            entries[setting["name"]].append(
                                {
                                    "port": pin_port,
                                    "pin": pin_number,
                                    "signal": signal["name"].lower(),
                                    "af": signal["af"],
                                    "drive": drive,
                                    "bias": bias,
                                }
                            )

            if not entries:
                continue

            # format entries (grouped and sorted)
            formatted_entries = ""
            for group, group_entries in entries.items():
                formatted_entries += PINCTRL_GROUP_TEMPLATE.format(group=group)

                sorted_group_entries = sorted(
                    group_entries, key=lambda entry: (entry["port"], entry["pin"])
                )
                for entry in sorted_group_entries:
                    formatted_entries += PINCTRL_ENTRY_TEMPLATE.format(
                        port=entry["port"],
                        pin=entry["pin"],
                        signal=entry["signal"],
                        af=entry["af"],
                        drive=entry["drive"],
                        bias=entry["bias"],
                    )
                formatted_entries += "\n"

            # write pinctrl file
            ref_file = os.path.join(family_dir, ref["name"].lower() + "-pinctrl.dtsi")
            with open(ref_file, "w") as f:
                f.write(
                    PINCTRL_TEMPLATE.format(
                        pinctrl_addr=pinctrl_addr,
                        pinctrl_entries=formatted_entries[:-2],
                    )
                )


if __name__ == "__main__":
    parser = argparse.ArgumentParser()
    parser.add_argument("-p", "--cube-path", required=True, help="CubeMX path")
    parser.add_argument("-o", "--output", required=True, help="Output directory")
    args = parser.parse_args()

    main(args.cube_path, args.output)
